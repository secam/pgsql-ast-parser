// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d: any[]): any { return d[0]; }
declare var lparen: any;
declare var rparen: any;
declare var dot: any;
declare var float: any;
declare var int: any;
declare var comma: any;
declare var star: any;
declare var string: any;
declare var eString: any;
declare var kw_primary: any;
declare var kw_unique: any;
declare var quoted_word: any;
declare var word: any;
declare var kw_not: any;
declare var kw_with: any;
declare var kw_null: any;
declare var kw_array: any;
declare var lbracket: any;
declare var rbracket: any;
declare var kw_precision: any;
declare var kw_as: any;
declare var kw_current_schema: any;
declare var kw_all: any;
declare var kw_analyse: any;
declare var kw_analyze: any;
declare var kw_and: any;
declare var kw_any: any;
declare var kw_asc: any;
declare var kw_asymmetric: any;
declare var kw_authorization: any;
declare var kw_binary: any;
declare var kw_both: any;
declare var kw_case: any;
declare var kw_cast: any;
declare var kw_check: any;
declare var kw_collate: any;
declare var kw_collation: any;
declare var kw_concurrently: any;
declare var kw_constraint: any;
declare var kw_create: any;
declare var kw_cross: any;
declare var kw_current_catalog: any;
declare var kw_current_date: any;
declare var kw_current_role: any;
declare var kw_current_time: any;
declare var kw_current_timestamp: any;
declare var kw_current_user: any;
declare var kw_default: any;
declare var kw_deferrable: any;
declare var kw_desc: any;
declare var kw_distinct: any;
declare var kw_do: any;
declare var kw_else: any;
declare var kw_end: any;
declare var kw_except: any;
declare var kw_false: any;
declare var kw_fetch: any;
declare var kw_for: any;
declare var kw_foreign: any;
declare var kw_freeze: any;
declare var kw_from: any;
declare var kw_full: any;
declare var kw_grant: any;
declare var kw_group: any;
declare var kw_having: any;
declare var kw_ilike: any;
declare var kw_in: any;
declare var kw_initially: any;
declare var kw_inner: any;
declare var kw_intersect: any;
declare var kw_into: any;
declare var kw_is: any;
declare var kw_isnull: any;
declare var kw_join: any;
declare var kw_lateral: any;
declare var kw_leading: any;
declare var kw_left: any;
declare var kw_like: any;
declare var kw_limit: any;
declare var kw_localtime: any;
declare var kw_localtimestamp: any;
declare var kw_natural: any;
declare var kw_notnull: any;
declare var kw_offset: any;
declare var kw_on: any;
declare var kw_only: any;
declare var kw_or: any;
declare var kw_order: any;
declare var kw_outer: any;
declare var kw_overlaps: any;
declare var kw_placing: any;
declare var kw_references: any;
declare var kw_returning: any;
declare var kw_right: any;
declare var kw_select: any;
declare var kw_session_user: any;
declare var kw_similar: any;
declare var kw_some: any;
declare var kw_symmetric: any;
declare var kw_table: any;
declare var kw_tablesample: any;
declare var kw_then: any;
declare var kw_to: any;
declare var kw_trailing: any;
declare var kw_true: any;
declare var kw_union: any;
declare var kw_user: any;
declare var kw_using: any;
declare var kw_variadic: any;
declare var kw_verbose: any;
declare var kw_when: any;
declare var kw_where: any;
declare var kw_window: any;
declare var kw_from: any;
declare var kw_lateral: any;
declare var kw_as: any;
declare var kw_join: any;
declare var kw_on: any;
declare var kw_using: any;
declare var comma: any;
declare var kw_inner: any;
declare var kw_cross: any;
declare var kw_left: any;
declare var kw_outer: any;
declare var kw_right: any;
declare var kw_full: any;
declare var kw_select: any;
declare var kw_all: any;
declare var kw_distinct: any;
declare var kw_where: any;
declare var kw_group: any;
declare var kw_having: any;
declare var kw_offset: any;
declare var kw_limit: any;
declare var kw_fetch: any;
declare var kw_only: any;
declare var kw_for: any;
declare var kw_order: any;
declare var kw_asc: any;
declare var kw_desc: any;
declare var kw_or: any;
declare var kw_and: any;
declare var kw_not: any;
declare var op_eq: any;
declare var op_neq: any;
declare var kw_isnull: any;
declare var kw_is: any;
declare var kw_null: any;
declare var kw_notnull: any;
declare var kw_true: any;
declare var kw_false: any;
declare var op_compare: any;
declare var ops_others: any;
declare var op_plus: any;
declare var op_minus: any;
declare var op_additive: any;
declare var star: any;
declare var op_div: any;
declare var op_mod: any;
declare var op_exp: any;
declare var lbracket: any;
declare var rbracket: any;
declare var op_cast: any;
declare var kw_cast: any;
declare var dot: any;
declare var kw_array: any;
declare var qparam: any;
declare var kw_default: any;
declare var kw_like: any;
declare var kw_ilike: any;
declare var op_like: any;
declare var op_ilike: any;
declare var op_not_like: any;
declare var op_not_ilike: any;
declare var kw_in: any;
declare var op_member: any;
declare var op_membertext: any;
declare var kw_case: any;
declare var kw_end: any;
declare var kw_when: any;
declare var kw_then: any;
declare var kw_else: any;
declare var kw_any: any;
declare var kw_some: any;
declare var kw_current_catalog: any;
declare var kw_current_date: any;
declare var kw_current_role: any;
declare var kw_current_schema: any;
declare var kw_current_timestamp: any;
declare var kw_current_time: any;
declare var kw_localtimestamp: any;
declare var kw_localtime: any;
declare var kw_session_user: any;
declare var kw_user: any;
declare var kw_current_user: any;
declare var lparen: any;
declare var kw_placing: any;
declare var rparen: any;
declare var kw_create: any;
declare var kw_table: any;
declare var kw_constraint: any;
declare var kw_unique: any;
declare var kw_check: any;
declare var kw_foreign: any;
declare var kw_references: any;
declare var kw_on: any;
declare var kw_full: any;
declare var kw_null: any;
declare var kw_default: any;
declare var kw_like: any;
declare var kw_all: any;
declare var kw_collate: any;
declare var comma: any;
declare var kw_create: any;
declare var kw_unique: any;
declare var kw_concurrently: any;
declare var kw_on: any;
declare var kw_using: any;
declare var kw_collate: any;
declare var kw_asc: any;
declare var kw_desc: any;
declare var kw_where: any;
declare var kw_with: any;
declare var comma: any;
declare var op_eq: any;
declare var kw_create: any;
declare var kw_with: any;
declare var kw_from: any;
declare var kw_default: any;
declare var kw_to: any;
declare var op_eq: any;
declare var word: any;
declare var kw_on: any;
declare var kw_true: any;
declare var kw_false: any;
declare var quoted_word: any;
declare var kw_create: any;
declare var kw_using: any;
declare var comma: any;
declare var kw_table: any;
declare var kw_is: any;
declare var kw_only: any;
declare var kw_not: any;
declare var kw_deferrable: any;
declare var kw_into: any;
declare var kw_user: any;
declare var kw_on: any;
declare var kw_returning: any;
declare var kw_constraint: any;
declare var kw_do: any;
declare var kw_where: any;
declare var kw_from: any;
declare var kw_returning: any;
declare var op_eq: any;
declare var kw_table: any;
declare var kw_only: any;
declare var kw_to: any;
declare var kw_constraint: any;
declare var kw_default: any;
declare var kw_as: any;
declare var kw_to: any;
declare var kw_from: any;
declare var kw_returning: any;
declare var kw_table: any;
declare var comma: any;
declare var kw_create: any;
declare var kw_as: any;
declare var kw_with: any;
declare var kw_to: any;
declare var kw_session_user: any;
declare var kw_current_user: any;
declare var comma: any;
declare var kw_table: any;
declare var kw_concurrently: any;
declare var kw_with: any;
declare var kw_as: any;
declare var kw_create: any;
declare var kw_as: any;
declare var comma: any;
declare var kw_to: any;
declare var kw_union: any;
declare var kw_all: any;
declare var kw_as: any;
declare var kw_all: any;
declare var kw_create: any;
declare var kw_or: any;
declare var comma: any;
declare var kw_as: any;
declare var kw_with: any;
declare var kw_check: any;
declare var op_eq: any;
declare var kw_concurrently: any;
declare var kw_with: any;
declare var kw_create: any;
declare var kw_or: any;
declare var comma: any;
declare var kw_default: any;
declare var op_eq: any;
declare var kw_in: any;
declare var kw_as: any;
declare var codeblock: any;
declare var kw_not: any;
declare var kw_null: any;
declare var kw_on: any;
declare var kw_table: any;
declare var kw_do: any;
declare var semicolon: any;
import {lexerAny} from '../lexer.ts';
import {track, box, unbox, doubleQuoted} from '../lexer.ts';

    // usage ex:  replace track(whatever) with debug(track)(whatever)
    function debug<T>(fn: any): any {
        fn = fn || ((x: any) => x);
        return ((x: any, ...args: any[]) => {
            debugger;
            return fn(x, ...args);
        });
    }

    function asName(val: any): any {
        return asNameWithColumns(val, undefined);
    }

    function asNameWithColumns(val: any, columns: any[] | undefined): any {
        const name = toStr(val);
        if (!columns || columns.length === 0) {
            return track(val, {name});
        }
        return track(val, {
            name,
            columns: columns.map(c => ({name: toStr(c)})),
        });
    }

    function asLit(val: any): any {
        const value = toStr(val);
        return track(val, {value});
    }

    function unwrap(e: any[]): any {
        if (Array.isArray(e) && e.length === 1) {
            e = unwrap(e[0]);
        }
        if (Array.isArray(e) && !e.length) {
            return null;
        }
        return unbox(e);
    }
    const get = (i: number) => (x: any[]) => track(x, x[i]);
    const last = (x: any[]) => Array.isArray(x) ? track(x[x.length - 1], x[x.length - 1]) : x;
    const trim = (x: string | null | undefined) => x && x.trim();
    const value = (x: any) => x && x.value;
    function flatten(e: any): any[] {
        if (Array.isArray(e)) {
            const ret = [];
            for (const i of e) {
                ret.push(...flatten(i));
            }
            return ret;
        }
        if (!e) {
            return [];
        }
        return [e];
    }
    function asStr(value: any) {
        value = unbox(value);
        return value?.value ?? value;
    }
    function flattenStr(e: any): string[] {
        const fl = flatten(unbox(e));
        return fl.filter(x => !!x)
                    .map(x => asStr(x))
                    .filter(x => typeof x === 'string')
                    .map(x => x.trim())
                    .filter(x => !!x);
    }
    function toStr(e: any, join?: string): string {
        return flattenStr(e).join(join || '');
    }

    function fromEntries(vals: [string, any][]): any {
        const ret = {} as any;
        for (const [k, v] of vals) {
            ret[k] = v;
        }
        return ret;
    }



 const kwSensitivity = { sensitivity: 'accent' };
 const eqInsensitive = (a: string, b: string) => a.localeCompare(b, undefined, kwSensitivity) === 0;
 const notReservedKw = (kw: string) => (x: any[], _: any, rej: any) => {
     const val = asStr(x[0]);
     if (eqInsensitive(val, kw)) {
         return box(x, kw);
     }
     return rej;
 }
 const kw = notReservedKw;
 const anyKw = (...kw: string[]) => {
     const kwSet = new Set(kw);
     return (x: any[], _: any, rej: any) => {
        const val = typeof x[0] === 'string' ? x[0] : x[0].value;
        return kwSet.has(val) ? val : rej;
    }
 }


function setSeqOpts(ret: any, opts: any) {
    const defs = new Set();
    const unboxed = opts.map(unbox);
    for (const [k, v] of unboxed) {
        if (defs.has(k)) {
            throw new Error('conflicting or redundant options');
        }
        defs.add(k);
        ret[k] = unbox(v);
    }
}

interface NearleyToken {
  value: any;
  [key: string]: any;
};

interface NearleyLexer {
  reset: (chunk: string, info: any) => void;
  next: () => NearleyToken | undefined;
  save: () => any;
  formatError: (token: never) => string;
  has: (tokenType: string) => boolean;
};

interface NearleyRule {
  name: string;
  symbols: NearleySymbol[];
  postprocess?: (d: any[], loc?: number, reject?: {}) => any;
};

type NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };

interface Grammar {
  Lexer: NearleyLexer | undefined;
  ParserRules: NearleyRule[];
  ParserStart: string;
};

const grammar: Grammar = {
  Lexer: lexerAny,
  ParserRules: [
    {"name": "lparen", "symbols": [(lexerAny.has("lparen") ? {type: "lparen"} : lparen)]},
    {"name": "rparen", "symbols": [(lexerAny.has("rparen") ? {type: "rparen"} : rparen)]},
    {"name": "number$subexpression$1", "symbols": ["float"]},
    {"name": "number$subexpression$1", "symbols": ["int"]},
    {"name": "number", "symbols": ["number$subexpression$1"], "postprocess": unwrap},
    {"name": "dot", "symbols": [(lexerAny.has("dot") ? {type: "dot"} : dot)], "postprocess": id},
    {"name": "float", "symbols": [(lexerAny.has("float") ? {type: "float"} : float)], "postprocess": x => box(x, parseFloat(unwrap(x)))},
    {"name": "int", "symbols": [(lexerAny.has("int") ? {type: "int"} : int)], "postprocess": x => box(x, parseInt(unwrap(x), 10))},
    {"name": "comma", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma)], "postprocess": id},
    {"name": "star", "symbols": [(lexerAny.has("star") ? {type: "star"} : star)], "postprocess": x => box(x, x[0].value)},
    {"name": "string$subexpression$1", "symbols": [(lexerAny.has("string") ? {type: "string"} : string)]},
    {"name": "string$subexpression$1", "symbols": [(lexerAny.has("eString") ? {type: "eString"} : eString)]},
    {"name": "string", "symbols": ["string$subexpression$1"], "postprocess": x => box(x, unwrap(x[0]).value)},
    {"name": "ident", "symbols": ["word"], "postprocess": get(0)},
    {"name": "word", "symbols": [(lexerAny.has("kw_primary") ? {type: "kw_primary"} : kw_primary)], "postprocess": x => box(x, 'primary')},
    {"name": "word", "symbols": [(lexerAny.has("kw_unique") ? {type: "kw_unique"} : kw_unique)], "postprocess": x => box(x, 'unique')},
    {"name": "word", "symbols": [(lexerAny.has("quoted_word") ? {type: "quoted_word"} : quoted_word)], "postprocess": x => box(x, x[0].value, true)},
    {"name": "word", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": x => box(x, x[0].value)},
    {"name": "collist_paren", "symbols": ["lparen", "collist", "rparen"], "postprocess": get(1)},
    {"name": "collist$ebnf$1", "symbols": []},
    {"name": "collist$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last},
    {"name": "collist$ebnf$1", "symbols": ["collist$ebnf$1", "collist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "collist", "symbols": ["ident", "collist$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "kw_between", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('between')},
    {"name": "kw_conflict", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('conflict')},
    {"name": "kw_nothing", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('nothing')},
    {"name": "kw_begin", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('begin')},
    {"name": "kw_if", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('if')},
    {"name": "kw_exists", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('exists')},
    {"name": "kw_key", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('key')},
    {"name": "kw_index", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('index')},
    {"name": "kw_extension", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('extension')},
    {"name": "kw_schema", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('schema')},
    {"name": "kw_nulls", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('nulls')},
    {"name": "kw_first", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('first')},
    {"name": "kw_last", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('last')},
    {"name": "kw_start", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('start')},
    {"name": "kw_restart", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('restart')},
    {"name": "kw_filter", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('filter')},
    {"name": "kw_commit", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('commit')},
    {"name": "kw_tablespace", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('tablespace')},
    {"name": "kw_transaction", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('transaction')},
    {"name": "kw_work", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('work')},
    {"name": "kw_read", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('read')},
    {"name": "kw_write", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('write')},
    {"name": "kw_isolation", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('isolation')},
    {"name": "kw_level", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('level')},
    {"name": "kw_serializable", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('serializable')},
    {"name": "kw_rollback", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('rollback')},
    {"name": "kw_insert", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('insert')},
    {"name": "kw_value", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('value')},
    {"name": "kw_values", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('values')},
    {"name": "kw_update", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('update')},
    {"name": "kw_column", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('column')},
    {"name": "kw_set", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('set')},
    {"name": "kw_version", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('version')},
    {"name": "kw_alter", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('alter')},
    {"name": "kw_rename", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('rename')},
    {"name": "kw_sequence", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('sequence')},
    {"name": "kw_temp", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('temp')},
    {"name": "kw_temporary", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('temporary')},
    {"name": "kw_add", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('add')},
    {"name": "kw_owner", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('owner')},
    {"name": "kw_owned", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('owned')},
    {"name": "kw_including", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('including')},
    {"name": "kw_excluding", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('excluding')},
    {"name": "kw_none", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('none')},
    {"name": "kw_drop", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('drop')},
    {"name": "kw_operator", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('operator')},
    {"name": "kw_minvalue", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('minvalue')},
    {"name": "kw_maxvalue", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('maxvalue')},
    {"name": "kw_data", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('data')},
    {"name": "kw_type", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('type')},
    {"name": "kw_trigger", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('trigger')},
    {"name": "kw_delete", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('delete')},
    {"name": "kw_cache", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('cache')},
    {"name": "kw_cascade", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('cascade')},
    {"name": "kw_no", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('no')},
    {"name": "kw_timestamp", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('timestamp')},
    {"name": "kw_cycle", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('cycle')},
    {"name": "kw_function", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('function')},
    {"name": "kw_returns", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('returns')},
    {"name": "kw_language", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('language')},
    {"name": "kw_out", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('out')},
    {"name": "kw_inout", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('inout')},
    {"name": "kw_variadic", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('variadic')},
    {"name": "kw_action", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('action')},
    {"name": "kw_restrict", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('restrict')},
    {"name": "kw_truncate", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('truncate')},
    {"name": "kw_increment", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('increment')},
    {"name": "kw_by", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('by')},
    {"name": "kw_row", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('row')},
    {"name": "kw_rows", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('rows')},
    {"name": "kw_next", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('next')},
    {"name": "kw_match", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('match')},
    {"name": "kw_replace", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('replace')},
    {"name": "kw_recursive", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('recursive')},
    {"name": "kw_view", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('view')},
    {"name": "kw_cascaded", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('cascaded')},
    {"name": "kw_unlogged", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('unlogged')},
    {"name": "kw_global", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('global')},
    {"name": "kw_option", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('option')},
    {"name": "kw_materialized", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('materialized')},
    {"name": "kw_partial", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('partial')},
    {"name": "kw_partition", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('partition')},
    {"name": "kw_simple", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('simple')},
    {"name": "kw_generated", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('generated')},
    {"name": "kw_always", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('always')},
    {"name": "kw_identity", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('identity')},
    {"name": "kw_name", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('name')},
    {"name": "kw_enum", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('enum')},
    {"name": "kw_show", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('show')},
    {"name": "kw_ordinality", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('ordinality')},
    {"name": "kw_overriding", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('overriding')},
    {"name": "kw_over", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('over')},
    {"name": "kw_system", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('system')},
    {"name": "kw_comment", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('comment')},
    {"name": "kw_time", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('time')},
    {"name": "kw_names", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('names')},
    {"name": "kw_at", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('at')},
    {"name": "kw_zone", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('zone')},
    {"name": "kw_interval", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('interval')},
    {"name": "kw_hour", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('hour')},
    {"name": "kw_minute", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('minute')},
    {"name": "kw_local", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('local')},
    {"name": "kw_session", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('session')},
    {"name": "kw_prepare", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('prepare')},
    {"name": "kw_deallocate", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('deallocate')},
    {"name": "kw_raise", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('raise')},
    {"name": "kw_continue", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('continue')},
    {"name": "kw_share", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('share')},
    {"name": "kw_refresh", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('refresh')},
    {"name": "kw_nowait", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('nowait')},
    {"name": "kw_skip", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('skip')},
    {"name": "kw_locked", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('locked')},
    {"name": "kw_within", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": notReservedKw('within')},
    {"name": "kw_ifnotexists", "symbols": ["kw_if", (lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not), "kw_exists"]},
    {"name": "kw_ifexists", "symbols": ["kw_if", "kw_exists"]},
    {"name": "kw_withordinality", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "kw_ordinality"]},
    {"name": "kw_not_null", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not), (lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null)]},
    {"name": "kw_primary_key", "symbols": [(lexerAny.has("kw_primary") ? {type: "kw_primary"} : kw_primary), "kw_key"]},
    {"name": "data_type$ebnf$1$subexpression$1$macrocall$2", "symbols": ["int"]},
    {"name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "symbols": []},
    {"name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "data_type$ebnf$1$subexpression$1$macrocall$2"], "postprocess": last},
    {"name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "symbols": ["data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "data_type$ebnf$1$subexpression$1$macrocall$1", "symbols": ["data_type$ebnf$1$subexpression$1$macrocall$2", "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "data_type$ebnf$1$subexpression$1", "symbols": ["lparen", "data_type$ebnf$1$subexpression$1$macrocall$1", "rparen"], "postprocess": get(1)},
    {"name": "data_type$ebnf$1", "symbols": ["data_type$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "data_type$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "data_type$ebnf$2$subexpression$1", "symbols": [(lexerAny.has("kw_array") ? {type: "kw_array"} : kw_array)]},
    {"name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("lbracket") ? {type: "lbracket"} : lbracket), (lexerAny.has("rbracket") ? {type: "rbracket"} : rbracket)]},
    {"name": "data_type$ebnf$2$subexpression$1$ebnf$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1"]},
    {"name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2", "symbols": [(lexerAny.has("lbracket") ? {type: "lbracket"} : lbracket), (lexerAny.has("rbracket") ? {type: "rbracket"} : rbracket)]},
    {"name": "data_type$ebnf$2$subexpression$1$ebnf$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1", "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "data_type$ebnf$2$subexpression$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1"]},
    {"name": "data_type$ebnf$2", "symbols": ["data_type$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "data_type$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "data_type", "symbols": ["data_type_simple", "data_type$ebnf$1", "data_type$ebnf$2"], "postprocess":  x => {
            let asArray = x[2];
            const name = unwrap(x[0]);
            let ret;
            ret = {
                ...name,
                ... Array.isArray(x[1]) && x[1].length ? { config: x[1].map(unwrap) } : {},
            };
            if (asArray) {
                if (asArray[0].type === 'kw_array') {
                    asArray = [['array']]
                }
                for (const _ of asArray[0]) {
                    ret = {
                        kind: 'array',
                        arrayOf: ret,
                    };
                }
            }
            return track(x, ret);
        } },
    {"name": "data_type_list$ebnf$1", "symbols": []},
    {"name": "data_type_list$ebnf$1$subexpression$1", "symbols": ["comma", "data_type"], "postprocess": last},
    {"name": "data_type_list$ebnf$1", "symbols": ["data_type_list$ebnf$1", "data_type_list$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "data_type_list", "symbols": ["data_type", "data_type_list$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "data_type_simple", "symbols": ["data_type_text"], "postprocess": x => track(x, { name: toStr(x, ' ') })},
    {"name": "data_type_simple", "symbols": ["data_type_numeric"], "postprocess": x => track(x, { name: toStr(x, ' ') })},
    {"name": "data_type_simple", "symbols": ["data_type_date"]},
    {"name": "data_type_simple", "symbols": ["qualified_name_mark_quotes"]},
    {"name": "data_type_numeric$subexpression$1", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('double')},
    {"name": "data_type_numeric", "symbols": ["data_type_numeric$subexpression$1", (lexerAny.has("kw_precision") ? {type: "kw_precision"} : kw_precision)]},
    {"name": "data_type_text$subexpression$1", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": anyKw('character', 'bit')},
    {"name": "data_type_text$subexpression$2", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('varying')},
    {"name": "data_type_text", "symbols": ["data_type_text$subexpression$1", "data_type_text$subexpression$2"]},
    {"name": "data_type_date$subexpression$1", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": anyKw('timestamp', 'time')},
    {"name": "data_type_date$subexpression$2", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with)]},
    {"name": "data_type_date$subexpression$2", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('without')},
    {"name": "data_type_date$subexpression$3", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('time')},
    {"name": "data_type_date$subexpression$4", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('zone')},
    {"name": "data_type_date", "symbols": ["data_type_date$subexpression$1", "data_type_date$subexpression$2", "data_type_date$subexpression$3", "data_type_date$subexpression$4"], "postprocess": x => track(x, { name: toStr(x, ' ') })},
    {"name": "data_type_date$subexpression$5", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": anyKw('timestamp', 'time')},
    {"name": "data_type_date$subexpression$6", "symbols": ["lparen", "int", "rparen"], "postprocess": get(1)},
    {"name": "data_type_date$subexpression$7", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with)]},
    {"name": "data_type_date$subexpression$7", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('without')},
    {"name": "data_type_date$subexpression$8", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('time')},
    {"name": "data_type_date$subexpression$9", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": kw('zone')},
    {"name": "data_type_date", "symbols": ["data_type_date$subexpression$5", "data_type_date$subexpression$6", "data_type_date$subexpression$7", "data_type_date$subexpression$8", "data_type_date$subexpression$9"], "postprocess": x => track(x, { name: `timestamp ${toStr(x[2])} time zone`, config: [unbox(x[1])] })},
    {"name": "ident_aliased$subexpression$1", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "ident"], "postprocess": last},
    {"name": "ident_aliased", "symbols": ["ident_aliased$subexpression$1"]},
    {"name": "ident_aliased", "symbols": ["ident"], "postprocess": unwrap},
    {"name": "table_ref", "symbols": ["qualified_name"], "postprocess": unwrap},
    {"name": "qcolumn$ebnf$1$subexpression$1", "symbols": ["dot", "ident"], "postprocess": last},
    {"name": "qcolumn$ebnf$1", "symbols": ["qcolumn$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "qcolumn$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "qcolumn", "symbols": ["ident", "dot", "ident", "qcolumn$ebnf$1"], "postprocess":  x => {
            if (!x[3]) {
                return track(x, {
                        table: unbox(x[0]),
                        column: unbox(x[2]),
                    });
            }
            return track(x, {
                schema: unbox(x[0]),
                table: unbox(x[2]),
                column: unbox(x[3]),
            });
        } },
    {"name": "table_ref_aliased$ebnf$1", "symbols": ["ident_aliased"], "postprocess": id},
    {"name": "table_ref_aliased$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "table_ref_aliased", "symbols": ["table_ref", "table_ref_aliased$ebnf$1"], "postprocess":  x => {
            const alias = unwrap(x[1]);
            return track(x, {
                ...unwrap(x[0]),
                ...alias ? { alias } : {},
            })
        } },
    {"name": "qualified_name", "symbols": ["qname_ident"], "postprocess": x => track(x, {name: toStr(x) })},
    {"name": "qualified_name", "symbols": ["ident", "dot", "ident_extended"], "postprocess":  x => {
            const schema = toStr(x[0]);
            const name = toStr(x[2]);
            return track(x, {schema, name});
        } },
    {"name": "qualified_name", "symbols": [(lexerAny.has("kw_current_schema") ? {type: "kw_current_schema"} : kw_current_schema)], "postprocess": x => track(x, { name: 'current_schema' })},
    {"name": "qualified_name_mark_quotes", "symbols": ["qname_ident"], "postprocess": x => track(x, {name: toStr(x), ...doubleQuoted(x) })},
    {"name": "qualified_name_mark_quotes", "symbols": ["ident", "dot", "ident_extended"], "postprocess":  x => {
            const schema = toStr(x[0]);
            const name = toStr(x[2]);
            return track(x, {schema, name, ...doubleQuoted(x[2])});
        } },
    {"name": "qualified_name_mark_quotes", "symbols": [(lexerAny.has("kw_current_schema") ? {type: "kw_current_schema"} : kw_current_schema)], "postprocess": x => track(x, { name: 'current_schema' })},
    {"name": "qname_ident", "symbols": ["ident"]},
    {"name": "qname_ident", "symbols": [(lexerAny.has("kw_precision") ? {type: "kw_precision"} : kw_precision)]},
    {"name": "qname", "symbols": ["qualified_name"], "postprocess": unwrap},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_analyse") ? {type: "kw_analyse"} : kw_analyse)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_analyze") ? {type: "kw_analyze"} : kw_analyze)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_and") ? {type: "kw_and"} : kw_and)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_any") ? {type: "kw_any"} : kw_any)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_array") ? {type: "kw_array"} : kw_array)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_asc") ? {type: "kw_asc"} : kw_asc)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_asymmetric") ? {type: "kw_asymmetric"} : kw_asymmetric)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_authorization") ? {type: "kw_authorization"} : kw_authorization)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_binary") ? {type: "kw_binary"} : kw_binary)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_both") ? {type: "kw_both"} : kw_both)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_case") ? {type: "kw_case"} : kw_case)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_cast") ? {type: "kw_cast"} : kw_cast)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_check") ? {type: "kw_check"} : kw_check)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_collate") ? {type: "kw_collate"} : kw_collate)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_collation") ? {type: "kw_collation"} : kw_collation)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_concurrently") ? {type: "kw_concurrently"} : kw_concurrently)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_constraint") ? {type: "kw_constraint"} : kw_constraint)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_cross") ? {type: "kw_cross"} : kw_cross)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_catalog") ? {type: "kw_current_catalog"} : kw_current_catalog)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_date") ? {type: "kw_current_date"} : kw_current_date)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_role") ? {type: "kw_current_role"} : kw_current_role)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_schema") ? {type: "kw_current_schema"} : kw_current_schema)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_time") ? {type: "kw_current_time"} : kw_current_time)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_timestamp") ? {type: "kw_current_timestamp"} : kw_current_timestamp)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_current_user") ? {type: "kw_current_user"} : kw_current_user)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_deferrable") ? {type: "kw_deferrable"} : kw_deferrable)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_desc") ? {type: "kw_desc"} : kw_desc)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_distinct") ? {type: "kw_distinct"} : kw_distinct)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_do") ? {type: "kw_do"} : kw_do)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_else") ? {type: "kw_else"} : kw_else)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_end") ? {type: "kw_end"} : kw_end)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_except") ? {type: "kw_except"} : kw_except)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_false") ? {type: "kw_false"} : kw_false)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_fetch") ? {type: "kw_fetch"} : kw_fetch)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_for") ? {type: "kw_for"} : kw_for)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_foreign") ? {type: "kw_foreign"} : kw_foreign)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_freeze") ? {type: "kw_freeze"} : kw_freeze)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_full") ? {type: "kw_full"} : kw_full)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_grant") ? {type: "kw_grant"} : kw_grant)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_group") ? {type: "kw_group"} : kw_group)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_having") ? {type: "kw_having"} : kw_having)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_ilike") ? {type: "kw_ilike"} : kw_ilike)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_in") ? {type: "kw_in"} : kw_in)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_initially") ? {type: "kw_initially"} : kw_initially)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_inner") ? {type: "kw_inner"} : kw_inner)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_intersect") ? {type: "kw_intersect"} : kw_intersect)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_into") ? {type: "kw_into"} : kw_into)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_is") ? {type: "kw_is"} : kw_is)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_isnull") ? {type: "kw_isnull"} : kw_isnull)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_join") ? {type: "kw_join"} : kw_join)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_lateral") ? {type: "kw_lateral"} : kw_lateral)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_leading") ? {type: "kw_leading"} : kw_leading)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_left") ? {type: "kw_left"} : kw_left)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_like") ? {type: "kw_like"} : kw_like)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_limit") ? {type: "kw_limit"} : kw_limit)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_localtime") ? {type: "kw_localtime"} : kw_localtime)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_localtimestamp") ? {type: "kw_localtimestamp"} : kw_localtimestamp)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_natural") ? {type: "kw_natural"} : kw_natural)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_notnull") ? {type: "kw_notnull"} : kw_notnull)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_offset") ? {type: "kw_offset"} : kw_offset)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_only") ? {type: "kw_only"} : kw_only)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_or") ? {type: "kw_or"} : kw_or)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_order") ? {type: "kw_order"} : kw_order)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_outer") ? {type: "kw_outer"} : kw_outer)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_overlaps") ? {type: "kw_overlaps"} : kw_overlaps)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_placing") ? {type: "kw_placing"} : kw_placing)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_primary") ? {type: "kw_primary"} : kw_primary)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_references") ? {type: "kw_references"} : kw_references)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_returning") ? {type: "kw_returning"} : kw_returning)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_right") ? {type: "kw_right"} : kw_right)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_select") ? {type: "kw_select"} : kw_select)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_session_user") ? {type: "kw_session_user"} : kw_session_user)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_similar") ? {type: "kw_similar"} : kw_similar)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_some") ? {type: "kw_some"} : kw_some)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_symmetric") ? {type: "kw_symmetric"} : kw_symmetric)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_tablesample") ? {type: "kw_tablesample"} : kw_tablesample)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_then") ? {type: "kw_then"} : kw_then)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_trailing") ? {type: "kw_trailing"} : kw_trailing)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_true") ? {type: "kw_true"} : kw_true)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_union") ? {type: "kw_union"} : kw_union)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_unique") ? {type: "kw_unique"} : kw_unique)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_user") ? {type: "kw_user"} : kw_user)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_using") ? {type: "kw_using"} : kw_using)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_variadic") ? {type: "kw_variadic"} : kw_variadic)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_verbose") ? {type: "kw_verbose"} : kw_verbose)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_when") ? {type: "kw_when"} : kw_when)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_where") ? {type: "kw_where"} : kw_where)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_window") ? {type: "kw_window"} : kw_window)]},
    {"name": "any_keyword", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with)]},
    {"name": "ident_extended", "symbols": ["ident"]},
    {"name": "ident_extended", "symbols": ["any_keyword"]},
    {"name": "select_statement$ebnf$1", "symbols": ["select_from"], "postprocess": id},
    {"name": "select_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$2", "symbols": ["select_where"], "postprocess": id},
    {"name": "select_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$3$subexpression$1$ebnf$1", "symbols": ["select_having"], "postprocess": id},
    {"name": "select_statement$ebnf$3$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$3$subexpression$1", "symbols": ["select_groupby", "select_statement$ebnf$3$subexpression$1$ebnf$1"]},
    {"name": "select_statement$ebnf$3", "symbols": ["select_statement$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "select_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$4", "symbols": ["select_order_by"], "postprocess": id},
    {"name": "select_statement$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$5", "symbols": ["select_limit_offset"], "postprocess": id},
    {"name": "select_statement$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$6$subexpression$1$ebnf$1", "symbols": ["select_skip"], "postprocess": id},
    {"name": "select_statement$ebnf$6$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_statement$ebnf$6$subexpression$1", "symbols": ["select_for", "select_statement$ebnf$6$subexpression$1$ebnf$1"]},
    {"name": "select_statement$ebnf$6", "symbols": ["select_statement$ebnf$6$subexpression$1"], "postprocess": id},
    {"name": "select_statement$ebnf$6", "symbols": [], "postprocess": () => null},
    {"name": "select_statement", "symbols": ["select_what", "select_statement$ebnf$1", "select_statement$ebnf$2", "select_statement$ebnf$3", "select_statement$ebnf$4", "select_statement$ebnf$5", "select_statement$ebnf$6"], "postprocess":  x => {
            let [what, from, where, _groupBy, orderBy, limit, _selectFor] = x;
            from = unwrap(from);
            let groupBy = _groupBy && _groupBy[0];
            let having = _groupBy && _groupBy[1];
            groupBy = groupBy && (groupBy.length === 1 && groupBy[0].type === 'list' ? groupBy[0].expressions : groupBy);
            having = having && unwrap(having);
            let selectFor = _selectFor && _selectFor[0];
            let skip = _selectFor && _selectFor[1];
            skip = unwrap(skip);
            return track(x, {
                ...what,
                ...from ? { from: Array.isArray(from) ? from : [from] } : {},
                ...groupBy ? { groupBy } : {},
                ...having ? { having } : {},
                ...limit ? { limit: unwrap(limit) } : {},
                ...orderBy ? { orderBy } : {},
                ...where ? { where } : {},
                ...selectFor ? { for: selectFor[1] } : {},
                ...skip ? { skip } : {},
                type: 'select',
            });
        } },
    {"name": "select_from", "symbols": [(lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from), "select_from_items"], "postprocess": last},
    {"name": "select_from_items$ebnf$1", "symbols": []},
    {"name": "select_from_items$ebnf$1$subexpression$1", "symbols": ["comma", "select_from_item"], "postprocess": last},
    {"name": "select_from_items$ebnf$1", "symbols": ["select_from_items$ebnf$1", "select_from_items$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "select_from_items", "symbols": ["select_from_item", "select_from_items$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [...head, ...(flatten(tail) || [])];
        } },
    {"name": "select_from_item", "symbols": ["select_from_subject"]},
    {"name": "select_from_item", "symbols": ["select_from_item_joins"], "postprocess": get(0)},
    {"name": "select_from_item_joins$subexpression$1", "symbols": ["select_from_item"], "postprocess": get(0)},
    {"name": "select_from_item_joins", "symbols": ["select_from_item_joins$subexpression$1", "select_table_join"], "postprocess": flatten},
    {"name": "select_from_item_joins", "symbols": ["lparen", "select_from_item_joins", "rparen"], "postprocess": get(1)},
    {"name": "select_from_subject", "symbols": ["stb_table"], "postprocess": unwrap},
    {"name": "select_from_subject", "symbols": ["stb_statement"], "postprocess": unwrap},
    {"name": "select_from_subject", "symbols": ["stb_call"], "postprocess": unwrap},
    {"name": "stb_opts$ebnf$1", "symbols": ["collist_paren"], "postprocess": id},
    {"name": "stb_opts$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "stb_opts", "symbols": ["ident_aliased", "stb_opts$ebnf$1"], "postprocess":  x => track(x, {
            alias: toStr(x[0]),
           ...x[1] && {columnNames: unbox(x[1]).map(asName)},
        }) },
    {"name": "stb_table$ebnf$1", "symbols": ["stb_opts"], "postprocess": id},
    {"name": "stb_table$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "stb_table", "symbols": ["table_ref", "stb_table$ebnf$1"], "postprocess":  x => {
            return track(x, {
                type: 'table',
                name: track(x, {
                    ...x[0],
                    ...x[1],
                }),
            });
        } },
    {"name": "stb_statement$ebnf$1", "symbols": [(lexerAny.has("kw_lateral") ? {type: "kw_lateral"} : kw_lateral)], "postprocess": id},
    {"name": "stb_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "stb_statement", "symbols": ["stb_statement$ebnf$1", "selection_paren", "stb_opts"], "postprocess":  x => track(x, {
            type: 'statement',
            statement: unwrap(x[1]),
            ...x[0] && { lateral: true },
            ...x[2],
        }) },
    {"name": "select_values", "symbols": ["kw_values", "insert_values"], "postprocess":  x => track(x, {
            type: 'values',
            values: x[1],
        }) },
    {"name": "stb_call$ebnf$1", "symbols": [(lexerAny.has("kw_lateral") ? {type: "kw_lateral"} : kw_lateral)], "postprocess": id},
    {"name": "stb_call$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "stb_call$ebnf$2", "symbols": ["kw_withordinality"], "postprocess": id},
    {"name": "stb_call$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "stb_call$ebnf$3", "symbols": ["stb_call_alias"], "postprocess": id},
    {"name": "stb_call$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "stb_call", "symbols": ["stb_call$ebnf$1", "expr_function_call", "stb_call$ebnf$2", "stb_call$ebnf$3"], "postprocess":  x => {
            const lateral = x[0];
            const withOrdinality = x[2];
            const alias = x[3];
        
            if (!withOrdinality && !alias) {
                return x[1];
            }
        
            return track(x, {
                ...x[1],
                ...lateral && { lateral: true },
                ... withOrdinality && { withOrdinality: true },
                alias: alias ? asNameWithColumns(alias[0], alias[1]) : undefined,
            });
        } },
    {"name": "stb_call_alias$subexpression$1$ebnf$1", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as)], "postprocess": id},
    {"name": "stb_call_alias$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "stb_call_alias$subexpression$1", "symbols": ["stb_call_alias$subexpression$1$ebnf$1", "ident"], "postprocess": last},
    {"name": "stb_call_alias$ebnf$1", "symbols": ["stb_call_alias_list"], "postprocess": id},
    {"name": "stb_call_alias$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "stb_call_alias", "symbols": ["stb_call_alias$subexpression$1", "stb_call_alias$ebnf$1"]},
    {"name": "stb_call_alias_list", "symbols": ["lparen", "stb_call_alias_list_raw", "rparen"], "postprocess": get(1)},
    {"name": "stb_call_alias_list_raw$ebnf$1", "symbols": []},
    {"name": "stb_call_alias_list_raw$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last},
    {"name": "stb_call_alias_list_raw$ebnf$1", "symbols": ["stb_call_alias_list_raw$ebnf$1", "stb_call_alias_list_raw$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "stb_call_alias_list_raw", "symbols": ["ident", "stb_call_alias_list_raw$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "select_table_join$ebnf$1", "symbols": ["select_table_join_clause"], "postprocess": id},
    {"name": "select_table_join$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_table_join", "symbols": ["select_join_op", (lexerAny.has("kw_join") ? {type: "kw_join"} : kw_join), "select_from_subject", "select_table_join$ebnf$1"], "postprocess":  x => track(x, {
            ...unwrap(x[2]),
            join: {
                type: toStr(x[0], ' '),
                ...x[3] && unwrap(x[3]),
            }
        }) },
    {"name": "select_table_join_clause", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "expr"], "postprocess": x => track(x, { on: last(x) })},
    {"name": "select_table_join_clause$macrocall$2", "symbols": ["ident"]},
    {"name": "select_table_join_clause$macrocall$1$ebnf$1", "symbols": []},
    {"name": "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "select_table_join_clause$macrocall$2"], "postprocess": last},
    {"name": "select_table_join_clause$macrocall$1$ebnf$1", "symbols": ["select_table_join_clause$macrocall$1$ebnf$1", "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "select_table_join_clause$macrocall$1", "symbols": ["select_table_join_clause$macrocall$2", "select_table_join_clause$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "select_table_join_clause", "symbols": [(lexerAny.has("kw_using") ? {type: "kw_using"} : kw_using), "lparen", "select_table_join_clause$macrocall$1", "rparen"], "postprocess": x => track(x, { using: x[2].map(asName) })},
    {"name": "select_join_op$subexpression$1$ebnf$1", "symbols": [(lexerAny.has("kw_inner") ? {type: "kw_inner"} : kw_inner)], "postprocess": id},
    {"name": "select_join_op$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_join_op$subexpression$1", "symbols": ["select_join_op$subexpression$1$ebnf$1"], "postprocess": x => box(x, 'INNER JOIN')},
    {"name": "select_join_op", "symbols": ["select_join_op$subexpression$1"]},
    {"name": "select_join_op$subexpression$2", "symbols": [(lexerAny.has("kw_cross") ? {type: "kw_cross"} : kw_cross)], "postprocess": x => box(x, 'CROSS JOIN')},
    {"name": "select_join_op", "symbols": ["select_join_op$subexpression$2"]},
    {"name": "select_join_op$subexpression$3$ebnf$1", "symbols": [(lexerAny.has("kw_outer") ? {type: "kw_outer"} : kw_outer)], "postprocess": id},
    {"name": "select_join_op$subexpression$3$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_join_op$subexpression$3", "symbols": [(lexerAny.has("kw_left") ? {type: "kw_left"} : kw_left), "select_join_op$subexpression$3$ebnf$1"], "postprocess": x => box(x, 'LEFT JOIN')},
    {"name": "select_join_op", "symbols": ["select_join_op$subexpression$3"]},
    {"name": "select_join_op$subexpression$4$ebnf$1", "symbols": [(lexerAny.has("kw_outer") ? {type: "kw_outer"} : kw_outer)], "postprocess": id},
    {"name": "select_join_op$subexpression$4$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_join_op$subexpression$4", "symbols": [(lexerAny.has("kw_right") ? {type: "kw_right"} : kw_right), "select_join_op$subexpression$4$ebnf$1"], "postprocess": x => box(x, 'RIGHT JOIN')},
    {"name": "select_join_op", "symbols": ["select_join_op$subexpression$4"]},
    {"name": "select_join_op$subexpression$5$ebnf$1", "symbols": [(lexerAny.has("kw_outer") ? {type: "kw_outer"} : kw_outer)], "postprocess": id},
    {"name": "select_join_op$subexpression$5$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_join_op$subexpression$5", "symbols": [(lexerAny.has("kw_full") ? {type: "kw_full"} : kw_full), "select_join_op$subexpression$5$ebnf$1"], "postprocess": x => box(x, 'FULL JOIN')},
    {"name": "select_join_op", "symbols": ["select_join_op$subexpression$5"]},
    {"name": "select_what$ebnf$1", "symbols": ["select_distinct"], "postprocess": id},
    {"name": "select_what$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_what$ebnf$2", "symbols": ["select_expr_list_aliased"], "postprocess": id},
    {"name": "select_what$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "select_what", "symbols": [(lexerAny.has("kw_select") ? {type: "kw_select"} : kw_select), "select_what$ebnf$1", "select_what$ebnf$2"], "postprocess":  x => track(x, {
            columns: x[2],
            ...x[1] && {distinct: unbox(x[1]) },
        }) },
    {"name": "select_expr_list_aliased$ebnf$1", "symbols": []},
    {"name": "select_expr_list_aliased$ebnf$1$subexpression$1", "symbols": ["comma", "select_expr_list_item"], "postprocess": last},
    {"name": "select_expr_list_aliased$ebnf$1", "symbols": ["select_expr_list_aliased$ebnf$1", "select_expr_list_aliased$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "select_expr_list_aliased", "symbols": ["select_expr_list_item", "select_expr_list_aliased$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "select_expr_list_item$ebnf$1", "symbols": ["ident_aliased"], "postprocess": id},
    {"name": "select_expr_list_item$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_expr_list_item", "symbols": ["expr", "select_expr_list_item$ebnf$1"], "postprocess":  x => track(x, {
            expr: x[0],
            ...x[1] ? {alias: asName(x[1]) } : {},
        }) },
    {"name": "select_distinct", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)], "postprocess": x => box(x, 'all')},
    {"name": "select_distinct$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "lparen", "expr_list_raw", "rparen"], "postprocess": get(2)},
    {"name": "select_distinct$ebnf$1", "symbols": ["select_distinct$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "select_distinct$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_distinct", "symbols": [(lexerAny.has("kw_distinct") ? {type: "kw_distinct"} : kw_distinct), "select_distinct$ebnf$1"], "postprocess": x => box(x, x[1] || 'distinct')},
    {"name": "select_where", "symbols": [(lexerAny.has("kw_where") ? {type: "kw_where"} : kw_where), "expr"], "postprocess": last},
    {"name": "select_groupby", "symbols": [(lexerAny.has("kw_group") ? {type: "kw_group"} : kw_group), "kw_by", "expr_list_raw"], "postprocess": last},
    {"name": "select_having", "symbols": [(lexerAny.has("kw_having") ? {type: "kw_having"} : kw_having), "expr"], "postprocess": last},
    {"name": "select_limit_offset$ebnf$1$subexpression$1", "symbols": ["select_offset"]},
    {"name": "select_limit_offset$ebnf$1$subexpression$1", "symbols": ["select_limit"]},
    {"name": "select_limit_offset$ebnf$1", "symbols": ["select_limit_offset$ebnf$1$subexpression$1"]},
    {"name": "select_limit_offset$ebnf$1$subexpression$2", "symbols": ["select_offset"]},
    {"name": "select_limit_offset$ebnf$1$subexpression$2", "symbols": ["select_limit"]},
    {"name": "select_limit_offset$ebnf$1", "symbols": ["select_limit_offset$ebnf$1", "select_limit_offset$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "select_limit_offset", "symbols": ["select_limit_offset$ebnf$1"], "postprocess":  (x, rej) => {
            const value = unwrap(x);
            if (!Array.isArray(value)) {
                return track(x, value);
            }
            if (value.length != 2) {
                return rej;
            }
            const a = unwrap(value[0]);
            const b = unwrap(value[1]);
            if (a.offset && b.offset || a.limit && b.limit) {
                return rej;
            }
            return track(x, {
                ...a,
                ...b,
            });
        } },
    {"name": "select_offset$ebnf$1$subexpression$1", "symbols": ["kw_row"]},
    {"name": "select_offset$ebnf$1$subexpression$1", "symbols": ["kw_rows"]},
    {"name": "select_offset$ebnf$1", "symbols": ["select_offset$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "select_offset$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_offset", "symbols": [(lexerAny.has("kw_offset") ? {type: "kw_offset"} : kw_offset), "expr_nostar", "select_offset$ebnf$1"], "postprocess": x => track(x, { offset: unwrap(x[1]) })},
    {"name": "select_limit$subexpression$1", "symbols": ["select_limit_1"]},
    {"name": "select_limit$subexpression$1", "symbols": ["select_limit_2"]},
    {"name": "select_limit", "symbols": ["select_limit$subexpression$1"], "postprocess": x => track(x, { limit: unwrap(x) })},
    {"name": "select_limit_1", "symbols": [(lexerAny.has("kw_limit") ? {type: "kw_limit"} : kw_limit), "expr_nostar"], "postprocess": last},
    {"name": "select_limit_2$ebnf$1$subexpression$1", "symbols": ["kw_first"]},
    {"name": "select_limit_2$ebnf$1$subexpression$1", "symbols": ["kw_next"]},
    {"name": "select_limit_2$ebnf$1", "symbols": ["select_limit_2$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "select_limit_2$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_limit_2$subexpression$1", "symbols": ["kw_row"]},
    {"name": "select_limit_2$subexpression$1", "symbols": ["kw_rows"]},
    {"name": "select_limit_2", "symbols": [(lexerAny.has("kw_fetch") ? {type: "kw_fetch"} : kw_fetch), "select_limit_2$ebnf$1", "expr_nostar", "select_limit_2$subexpression$1", (lexerAny.has("kw_only") ? {type: "kw_only"} : kw_only)], "postprocess": get(2)},
    {"name": "select_for$subexpression$1", "symbols": ["kw_update"], "postprocess": x => track(x, {type: 'update'})},
    {"name": "select_for$subexpression$1", "symbols": ["kw_no", "kw_key", "kw_update"], "postprocess": x => track(x, {type: 'no key update'})},
    {"name": "select_for$subexpression$1", "symbols": ["kw_share"], "postprocess": x => track(x, {type: 'share'})},
    {"name": "select_for$subexpression$1", "symbols": ["kw_key", "kw_share"], "postprocess": x => track(x, {type: 'key share'})},
    {"name": "select_for", "symbols": [(lexerAny.has("kw_for") ? {type: "kw_for"} : kw_for), "select_for$subexpression$1"]},
    {"name": "select_skip$subexpression$1", "symbols": ["kw_nowait"], "postprocess": x => track(x, {type: 'nowait'})},
    {"name": "select_skip$subexpression$1", "symbols": ["kw_skip", "kw_locked"], "postprocess": x => track(x, {type: 'skip locked'})},
    {"name": "select_skip", "symbols": ["select_skip$subexpression$1"]},
    {"name": "select_order_by$subexpression$1", "symbols": [(lexerAny.has("kw_order") ? {type: "kw_order"} : kw_order), "kw_by"]},
    {"name": "select_order_by$ebnf$1", "symbols": []},
    {"name": "select_order_by$ebnf$1$subexpression$1", "symbols": ["comma", "select_order_by_expr"], "postprocess": last},
    {"name": "select_order_by$ebnf$1", "symbols": ["select_order_by$ebnf$1", "select_order_by$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "select_order_by", "symbols": ["select_order_by$subexpression$1", "select_order_by_expr", "select_order_by$ebnf$1"], "postprocess":  ([_, head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "select_order_by_expr$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_asc") ? {type: "kw_asc"} : kw_asc)]},
    {"name": "select_order_by_expr$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_desc") ? {type: "kw_desc"} : kw_desc)]},
    {"name": "select_order_by_expr$ebnf$1", "symbols": ["select_order_by_expr$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "select_order_by_expr$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_first"]},
    {"name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_last"]},
    {"name": "select_order_by_expr$ebnf$2$subexpression$1", "symbols": ["kw_nulls", "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1"], "postprocess": last},
    {"name": "select_order_by_expr$ebnf$2", "symbols": ["select_order_by_expr$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "select_order_by_expr$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "select_order_by_expr", "symbols": ["expr", "select_order_by_expr$ebnf$1", "select_order_by_expr$ebnf$2"], "postprocess":  x => track(x, {
            by: x[0],
            ...x[1] && {order: toStr(x[1]).toUpperCase()},
            ...x[2] && {nulls: toStr(x[2]).toUpperCase()},
        }) },
    {"name": "expr", "symbols": ["expr_nostar"], "postprocess": unwrap},
    {"name": "expr", "symbols": ["expr_star"], "postprocess": unwrap},
    {"name": "expr_nostar", "symbols": ["expr_paren"], "postprocess": unwrap},
    {"name": "expr_nostar", "symbols": ["expr_or"], "postprocess": unwrap},
    {"name": "expr_paren$subexpression$1", "symbols": ["expr_or_select"]},
    {"name": "expr_paren$subexpression$1", "symbols": ["expr_list_many"]},
    {"name": "expr_paren", "symbols": ["lparen", "expr_paren$subexpression$1", "rparen"], "postprocess": get(1)},
    {"name": "expr_or$macrocall$2$macrocall$2", "symbols": [(lexerAny.has("kw_or") ? {type: "kw_or"} : kw_or)]},
    {"name": "expr_or$macrocall$2$macrocall$1", "symbols": ["expr_or$macrocall$2$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_or$macrocall$2", "symbols": ["expr_or$macrocall$2$macrocall$1"]},
    {"name": "expr_or$macrocall$3", "symbols": ["expr_or"]},
    {"name": "expr_or$macrocall$4", "symbols": ["expr_and"]},
    {"name": "expr_or$macrocall$1$subexpression$1", "symbols": ["expr_or$macrocall$3"]},
    {"name": "expr_or$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_or$macrocall$1$subexpression$2", "symbols": ["expr_or$macrocall$4"]},
    {"name": "expr_or$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_or$macrocall$1", "symbols": ["expr_or$macrocall$1$subexpression$1", "expr_or$macrocall$2", "expr_or$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_or$macrocall$1", "symbols": ["expr_or$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_or", "symbols": ["expr_or$macrocall$1"]},
    {"name": "expr_and$macrocall$2$macrocall$2", "symbols": [(lexerAny.has("kw_and") ? {type: "kw_and"} : kw_and)]},
    {"name": "expr_and$macrocall$2$macrocall$1", "symbols": ["expr_and$macrocall$2$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_and$macrocall$2", "symbols": ["expr_and$macrocall$2$macrocall$1"]},
    {"name": "expr_and$macrocall$3", "symbols": ["expr_and"]},
    {"name": "expr_and$macrocall$4", "symbols": ["expr_not"]},
    {"name": "expr_and$macrocall$1$subexpression$1", "symbols": ["expr_and$macrocall$3"]},
    {"name": "expr_and$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_and$macrocall$1$subexpression$2", "symbols": ["expr_and$macrocall$4"]},
    {"name": "expr_and$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_and$macrocall$1", "symbols": ["expr_and$macrocall$1$subexpression$1", "expr_and$macrocall$2", "expr_and$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_and$macrocall$1", "symbols": ["expr_and$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_and", "symbols": ["expr_and$macrocall$1"]},
    {"name": "expr_not$macrocall$2$macrocall$2", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)]},
    {"name": "expr_not$macrocall$2$macrocall$1", "symbols": ["expr_not$macrocall$2$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_not$macrocall$2", "symbols": ["expr_not$macrocall$2$macrocall$1"]},
    {"name": "expr_not$macrocall$3", "symbols": ["expr_not"]},
    {"name": "expr_not$macrocall$4", "symbols": ["expr_eq"]},
    {"name": "expr_not$macrocall$1$subexpression$1", "symbols": ["expr_not$macrocall$3"]},
    {"name": "expr_not$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_not$macrocall$1", "symbols": ["expr_not$macrocall$2", "expr_not$macrocall$1$subexpression$1"], "postprocess":  x => track(x, {
            type: 'unary',
            ...unwrap(x[0]),
            operand: unwrap(x[1]),
        }) },
    {"name": "expr_not$macrocall$1", "symbols": ["expr_not$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_not", "symbols": ["expr_not$macrocall$1"]},
    {"name": "expr_eq$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq)]},
    {"name": "expr_eq$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_neq") ? {type: "op_neq"} : op_neq)]},
    {"name": "expr_eq$macrocall$2$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$2$subexpression$1"]},
    {"name": "expr_eq$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$2"]},
    {"name": "expr_eq$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_eq$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_eq$macrocall$2$macrocall$1", "symbols": ["expr_eq$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_eq$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_eq$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_eq$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$1"]},
    {"name": "expr_eq$macrocall$3", "symbols": ["expr_eq"]},
    {"name": "expr_eq$macrocall$4", "symbols": ["expr_is"]},
    {"name": "expr_eq$macrocall$1$subexpression$1", "symbols": ["expr_eq$macrocall$3"]},
    {"name": "expr_eq$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_eq$macrocall$1$subexpression$2", "symbols": ["expr_eq$macrocall$4"]},
    {"name": "expr_eq$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_eq$macrocall$1", "symbols": ["expr_eq$macrocall$1$subexpression$1", "expr_eq$macrocall$2", "expr_eq$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_eq$macrocall$1", "symbols": ["expr_eq$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_eq", "symbols": ["expr_eq$macrocall$1"]},
    {"name": "expr_star", "symbols": ["star"], "postprocess": x => track(x, { type: 'ref', name: '*' })},
    {"name": "expr_is$subexpression$1", "symbols": ["expr_is"]},
    {"name": "expr_is$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_is$subexpression$2", "symbols": [(lexerAny.has("kw_isnull") ? {type: "kw_isnull"} : kw_isnull)]},
    {"name": "expr_is$subexpression$2", "symbols": [(lexerAny.has("kw_is") ? {type: "kw_is"} : kw_is), (lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null)]},
    {"name": "expr_is", "symbols": ["expr_is$subexpression$1", "expr_is$subexpression$2"], "postprocess": x => track(x, { type: 'unary', op: 'IS NULL', operand: unwrap(x[0]) })},
    {"name": "expr_is$subexpression$3", "symbols": ["expr_is"]},
    {"name": "expr_is$subexpression$3", "symbols": ["expr_paren"]},
    {"name": "expr_is$subexpression$4", "symbols": [(lexerAny.has("kw_notnull") ? {type: "kw_notnull"} : kw_notnull)]},
    {"name": "expr_is$subexpression$4", "symbols": [(lexerAny.has("kw_is") ? {type: "kw_is"} : kw_is), "kw_not_null"]},
    {"name": "expr_is", "symbols": ["expr_is$subexpression$3", "expr_is$subexpression$4"], "postprocess": x => track(x, { type: 'unary', op: 'IS NOT NULL', operand: unwrap(x[0])})},
    {"name": "expr_is$subexpression$5", "symbols": ["expr_is"]},
    {"name": "expr_is$subexpression$5", "symbols": ["expr_paren"]},
    {"name": "expr_is$ebnf$1", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)], "postprocess": id},
    {"name": "expr_is$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_is$subexpression$6", "symbols": [(lexerAny.has("kw_true") ? {type: "kw_true"} : kw_true)]},
    {"name": "expr_is$subexpression$6", "symbols": [(lexerAny.has("kw_false") ? {type: "kw_false"} : kw_false)]},
    {"name": "expr_is", "symbols": ["expr_is$subexpression$5", (lexerAny.has("kw_is") ? {type: "kw_is"} : kw_is), "expr_is$ebnf$1", "expr_is$subexpression$6"], "postprocess":  x => track(x, {
            type: 'unary',
            op: 'IS ' + flattenStr([x[2], x[3]])
                .join(' ')
                .toUpperCase(),
            operand: unwrap(x[0]),
        }) },
    {"name": "expr_is", "symbols": ["expr_compare"], "postprocess": unwrap},
    {"name": "expr_compare$macrocall$2$macrocall$2", "symbols": [(lexerAny.has("op_compare") ? {type: "op_compare"} : op_compare)]},
    {"name": "expr_compare$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_compare$macrocall$2$macrocall$2"]},
    {"name": "expr_compare$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_compare$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_compare$macrocall$2$macrocall$1", "symbols": ["expr_compare$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_compare$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_compare$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_compare$macrocall$2", "symbols": ["expr_compare$macrocall$2$macrocall$1"]},
    {"name": "expr_compare$macrocall$3", "symbols": ["expr_compare"]},
    {"name": "expr_compare$macrocall$4", "symbols": ["expr_range"]},
    {"name": "expr_compare$macrocall$1$subexpression$1", "symbols": ["expr_compare$macrocall$3"]},
    {"name": "expr_compare$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_compare$macrocall$1$subexpression$2", "symbols": ["expr_compare$macrocall$4"]},
    {"name": "expr_compare$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_compare$macrocall$1", "symbols": ["expr_compare$macrocall$1$subexpression$1", "expr_compare$macrocall$2", "expr_compare$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_compare$macrocall$1", "symbols": ["expr_compare$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_compare", "symbols": ["expr_compare$macrocall$1"]},
    {"name": "expr_range$macrocall$2", "symbols": ["ops_between"]},
    {"name": "expr_range$macrocall$3", "symbols": [(lexerAny.has("kw_and") ? {type: "kw_and"} : kw_and)]},
    {"name": "expr_range$macrocall$4", "symbols": ["expr_range"]},
    {"name": "expr_range$macrocall$5", "symbols": ["expr_others"]},
    {"name": "expr_range$macrocall$1$subexpression$1", "symbols": ["expr_range$macrocall$4"]},
    {"name": "expr_range$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_range$macrocall$1$subexpression$2", "symbols": ["expr_range$macrocall$4"]},
    {"name": "expr_range$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_range$macrocall$1$subexpression$3", "symbols": ["expr_range$macrocall$5"]},
    {"name": "expr_range$macrocall$1$subexpression$3", "symbols": ["expr_paren"]},
    {"name": "expr_range$macrocall$1", "symbols": ["expr_range$macrocall$1$subexpression$1", "expr_range$macrocall$2", "expr_range$macrocall$1$subexpression$2", "expr_range$macrocall$3", "expr_range$macrocall$1$subexpression$3"], "postprocess":  x => track(x, {
            type: 'ternary',
            value: unwrap(x[0]),
            lo: unwrap(x[2]),
            hi: unwrap(x[4]),
            op: (flattenStr(x[1]).join(' ') || '<error>').toUpperCase(),
        }) },
    {"name": "expr_range$macrocall$1", "symbols": ["expr_range$macrocall$5"], "postprocess": unwrap},
    {"name": "expr_range", "symbols": ["expr_range$macrocall$1"]},
    {"name": "expr_others$macrocall$2$macrocall$2", "symbols": [(lexerAny.has("ops_others") ? {type: "ops_others"} : ops_others)]},
    {"name": "expr_others$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_others$macrocall$2$macrocall$2"]},
    {"name": "expr_others$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_others$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_others$macrocall$2$macrocall$1", "symbols": ["expr_others$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_others$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_others$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_others$macrocall$2", "symbols": ["expr_others$macrocall$2$macrocall$1"]},
    {"name": "expr_others$macrocall$3", "symbols": ["expr_others"]},
    {"name": "expr_others$macrocall$4", "symbols": ["expr_like"]},
    {"name": "expr_others$macrocall$1$subexpression$1", "symbols": ["expr_others$macrocall$3"]},
    {"name": "expr_others$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_others$macrocall$1$subexpression$2", "symbols": ["expr_others$macrocall$4"]},
    {"name": "expr_others$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_others$macrocall$1", "symbols": ["expr_others$macrocall$1$subexpression$1", "expr_others$macrocall$2", "expr_others$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_others$macrocall$1", "symbols": ["expr_others$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_others", "symbols": ["expr_others$macrocall$1"]},
    {"name": "expr_like$macrocall$2$macrocall$2", "symbols": ["ops_like"]},
    {"name": "expr_like$macrocall$2$macrocall$1", "symbols": ["expr_like$macrocall$2$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_like$macrocall$2", "symbols": ["expr_like$macrocall$2$macrocall$1"]},
    {"name": "expr_like$macrocall$3", "symbols": ["expr_like"]},
    {"name": "expr_like$macrocall$4", "symbols": ["expr_in"]},
    {"name": "expr_like$macrocall$1$subexpression$1", "symbols": ["expr_like$macrocall$3"]},
    {"name": "expr_like$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_like$macrocall$1$subexpression$2", "symbols": ["expr_like$macrocall$4"]},
    {"name": "expr_like$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_like$macrocall$1", "symbols": ["expr_like$macrocall$1$subexpression$1", "expr_like$macrocall$2", "expr_like$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_like$macrocall$1", "symbols": ["expr_like$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_like", "symbols": ["expr_like$macrocall$1"]},
    {"name": "expr_in$macrocall$2$macrocall$2", "symbols": ["ops_in"]},
    {"name": "expr_in$macrocall$2$macrocall$1", "symbols": ["expr_in$macrocall$2$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_in$macrocall$2", "symbols": ["expr_in$macrocall$2$macrocall$1"]},
    {"name": "expr_in$macrocall$3", "symbols": ["expr_in"]},
    {"name": "expr_in$macrocall$4", "symbols": ["expr_add"]},
    {"name": "expr_in$macrocall$1$subexpression$1", "symbols": ["expr_in$macrocall$3"]},
    {"name": "expr_in$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_in$macrocall$1$subexpression$2", "symbols": ["expr_in$macrocall$4"]},
    {"name": "expr_in$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_in$macrocall$1", "symbols": ["expr_in$macrocall$1$subexpression$1", "expr_in$macrocall$2", "expr_in$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_in$macrocall$1", "symbols": ["expr_in$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_in", "symbols": ["expr_in$macrocall$1"]},
    {"name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_plus") ? {type: "op_plus"} : op_plus)]},
    {"name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_minus") ? {type: "op_minus"} : op_minus)]},
    {"name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_additive") ? {type: "op_additive"} : op_additive)]},
    {"name": "expr_add$macrocall$2$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$2$subexpression$1"]},
    {"name": "expr_add$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$2"]},
    {"name": "expr_add$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_add$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_add$macrocall$2$macrocall$1", "symbols": ["expr_add$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_add$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_add$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_add$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$1"]},
    {"name": "expr_add$macrocall$3", "symbols": ["expr_add"]},
    {"name": "expr_add$macrocall$4", "symbols": ["expr_mult"]},
    {"name": "expr_add$macrocall$1$subexpression$1", "symbols": ["expr_add$macrocall$3"]},
    {"name": "expr_add$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_add$macrocall$1$subexpression$2", "symbols": ["expr_add$macrocall$4"]},
    {"name": "expr_add$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_add$macrocall$1", "symbols": ["expr_add$macrocall$1$subexpression$1", "expr_add$macrocall$2", "expr_add$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_add$macrocall$1", "symbols": ["expr_add$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_add", "symbols": ["expr_add$macrocall$1"]},
    {"name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("star") ? {type: "star"} : star)]},
    {"name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_div") ? {type: "op_div"} : op_div)]},
    {"name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_mod") ? {type: "op_mod"} : op_mod)]},
    {"name": "expr_mult$macrocall$2$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$2$subexpression$1"]},
    {"name": "expr_mult$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$2"]},
    {"name": "expr_mult$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_mult$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_mult$macrocall$2$macrocall$1", "symbols": ["expr_mult$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_mult$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_mult$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_mult$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$1"]},
    {"name": "expr_mult$macrocall$3", "symbols": ["expr_mult"]},
    {"name": "expr_mult$macrocall$4", "symbols": ["expr_exp"]},
    {"name": "expr_mult$macrocall$1$subexpression$1", "symbols": ["expr_mult$macrocall$3"]},
    {"name": "expr_mult$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_mult$macrocall$1$subexpression$2", "symbols": ["expr_mult$macrocall$4"]},
    {"name": "expr_mult$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_mult$macrocall$1", "symbols": ["expr_mult$macrocall$1$subexpression$1", "expr_mult$macrocall$2", "expr_mult$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_mult$macrocall$1", "symbols": ["expr_mult$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_mult", "symbols": ["expr_mult$macrocall$1"]},
    {"name": "expr_exp$macrocall$2$macrocall$2", "symbols": [(lexerAny.has("op_exp") ? {type: "op_exp"} : op_exp)]},
    {"name": "expr_exp$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_exp$macrocall$2$macrocall$2"]},
    {"name": "expr_exp$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_exp$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_exp$macrocall$2$macrocall$1", "symbols": ["expr_exp$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_exp$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_exp$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_exp$macrocall$2", "symbols": ["expr_exp$macrocall$2$macrocall$1"]},
    {"name": "expr_exp$macrocall$3", "symbols": ["expr_exp"]},
    {"name": "expr_exp$macrocall$4", "symbols": ["expr_unary_add"]},
    {"name": "expr_exp$macrocall$1$subexpression$1", "symbols": ["expr_exp$macrocall$3"]},
    {"name": "expr_exp$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_exp$macrocall$1$subexpression$2", "symbols": ["expr_exp$macrocall$4"]},
    {"name": "expr_exp$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_exp$macrocall$1", "symbols": ["expr_exp$macrocall$1$subexpression$1", "expr_exp$macrocall$2", "expr_exp$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_exp$macrocall$1", "symbols": ["expr_exp$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_exp", "symbols": ["expr_exp$macrocall$1"]},
    {"name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_plus") ? {type: "op_plus"} : op_plus)]},
    {"name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [(lexerAny.has("op_minus") ? {type: "op_minus"} : op_minus)]},
    {"name": "expr_unary_add$macrocall$2$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$2$subexpression$1"]},
    {"name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$2"]},
    {"name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_unary_add$macrocall$2$macrocall$1$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_unary_add$macrocall$2$macrocall$1", "symbols": ["expr_unary_add$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap},
    {"name": "expr_unary_add$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_unary_add$macrocall$2$macrocall$2", "rparen"], "postprocess":  x => track(x, {
            op:  (toStr(x[4], ' ') || '<error>').toUpperCase(),
            opSchema: toStr(x[2]),
        })},
    {"name": "expr_unary_add$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$1"]},
    {"name": "expr_unary_add$macrocall$3", "symbols": ["expr_unary_add"]},
    {"name": "expr_unary_add$macrocall$4", "symbols": ["expr_various_constructs"]},
    {"name": "expr_unary_add$macrocall$1$subexpression$1", "symbols": ["expr_unary_add$macrocall$3"]},
    {"name": "expr_unary_add$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_unary_add$macrocall$1", "symbols": ["expr_unary_add$macrocall$2", "expr_unary_add$macrocall$1$subexpression$1"], "postprocess":  x => track(x, {
            type: 'unary',
            ...unwrap(x[0]),
            operand: unwrap(x[1]),
        }) },
    {"name": "expr_unary_add$macrocall$1", "symbols": ["expr_unary_add$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_unary_add", "symbols": ["expr_unary_add$macrocall$1"]},
    {"name": "expr_various_constructs$macrocall$2$macrocall$2", "symbols": ["various_binaries"]},
    {"name": "expr_various_constructs$macrocall$2$macrocall$1", "symbols": ["expr_various_constructs$macrocall$2$macrocall$2"], "postprocess":  x => track(x, {
            op: (toStr(x, ' ') || '<error>').toUpperCase()
        }) },
    {"name": "expr_various_constructs$macrocall$2", "symbols": ["expr_various_constructs$macrocall$2$macrocall$1"]},
    {"name": "expr_various_constructs$macrocall$3", "symbols": ["expr_various_constructs"]},
    {"name": "expr_various_constructs$macrocall$4", "symbols": ["expr_array_index"]},
    {"name": "expr_various_constructs$macrocall$1$subexpression$1", "symbols": ["expr_various_constructs$macrocall$3"]},
    {"name": "expr_various_constructs$macrocall$1$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_various_constructs$macrocall$1$subexpression$2", "symbols": ["expr_various_constructs$macrocall$4"]},
    {"name": "expr_various_constructs$macrocall$1$subexpression$2", "symbols": ["expr_paren"]},
    {"name": "expr_various_constructs$macrocall$1", "symbols": ["expr_various_constructs$macrocall$1$subexpression$1", "expr_various_constructs$macrocall$2", "expr_various_constructs$macrocall$1$subexpression$2"], "postprocess":  x => track(x, {
            type: 'binary',
            left: unwrap(x[0]),
            right: unwrap(x[2]),
            ...unwrap(x[1]),
        }) },
    {"name": "expr_various_constructs$macrocall$1", "symbols": ["expr_various_constructs$macrocall$4"], "postprocess": unwrap},
    {"name": "expr_various_constructs", "symbols": ["expr_various_constructs$macrocall$1"]},
    {"name": "expr_array_index$subexpression$1", "symbols": ["expr_array_index"]},
    {"name": "expr_array_index$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_array_index", "symbols": ["expr_array_index$subexpression$1", (lexerAny.has("lbracket") ? {type: "lbracket"} : lbracket), "expr_nostar", (lexerAny.has("rbracket") ? {type: "rbracket"} : rbracket)], "postprocess":  x => track(x, {
            type: 'arrayIndex',
            array: unwrap(x[0]),
            index: unwrap(x[2]),
        }) },
    {"name": "expr_array_index", "symbols": ["expr_member"], "postprocess": unwrap},
    {"name": "expr_member$subexpression$1", "symbols": ["expr_member"]},
    {"name": "expr_member$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "expr_member$subexpression$2", "symbols": ["string"]},
    {"name": "expr_member$subexpression$2", "symbols": ["int"]},
    {"name": "expr_member", "symbols": ["expr_member$subexpression$1", "ops_member", "expr_member$subexpression$2"], "postprocess":  x => track(x, {
            type: 'member',
            operand: unwrap(x[0]),
            op: x[1],
            member: unwrap(x[2])
        }) },
    {"name": "expr_member$subexpression$3", "symbols": ["expr_member"]},
    {"name": "expr_member$subexpression$3", "symbols": ["expr_paren"]},
    {"name": "expr_member", "symbols": ["expr_member$subexpression$3", (lexerAny.has("op_cast") ? {type: "op_cast"} : op_cast), "data_type"], "postprocess":  x => track(x, {
            type: 'cast',
            operand: unwrap(x[0]),
            to: x[2],
        }) },
    {"name": "expr_member", "symbols": [(lexerAny.has("kw_cast") ? {type: "kw_cast"} : kw_cast), "lparen", "expr_nostar", (lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "data_type", "rparen"], "postprocess":  x => track(x, {
            type: 'cast',
            operand: unwrap(x[2]),
            to: x[4],
        }) },
    {"name": "expr_member", "symbols": ["data_type", "string"], "postprocess":  x => track(x, {
            type: 'cast',
            operand: track(x[1], {
                type: 'string',
                value: unbox(x[1]),
            }),
            to: unbox(x[0]),
        }) },
    {"name": "expr_member", "symbols": ["expr_dot"], "postprocess": unwrap},
    {"name": "expr_dot$subexpression$1", "symbols": ["word"]},
    {"name": "expr_dot$subexpression$1", "symbols": ["star"]},
    {"name": "expr_dot", "symbols": ["qname", (lexerAny.has("dot") ? {type: "dot"} : dot), "expr_dot$subexpression$1"], "postprocess":  x => track(x, {
            type: 'ref',
            table: unwrap(x[0]),
            name: toStr(x[2])
        }) },
    {"name": "expr_dot", "symbols": ["expr_final"], "postprocess": unwrap},
    {"name": "expr_final", "symbols": ["expr_basic"]},
    {"name": "expr_final", "symbols": ["expr_primary"]},
    {"name": "expr_basic", "symbols": ["expr_special_calls"]},
    {"name": "expr_basic", "symbols": ["expr_call"]},
    {"name": "expr_basic", "symbols": ["expr_array"]},
    {"name": "expr_basic", "symbols": ["expr_case"]},
    {"name": "expr_basic", "symbols": ["expr_extract"]},
    {"name": "expr_basic", "symbols": ["word"], "postprocess":  x => track(x, {
            type: 'ref',
            name: unwrap(x[0]),
        }) },
    {"name": "expr_array$ebnf$1", "symbols": ["expr_subarray_items"], "postprocess": id},
    {"name": "expr_array$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_array", "symbols": [(lexerAny.has("kw_array") ? {type: "kw_array"} : kw_array), (lexerAny.has("lbracket") ? {type: "lbracket"} : lbracket), "expr_array$ebnf$1", (lexerAny.has("rbracket") ? {type: "rbracket"} : rbracket)], "postprocess":  x => track(x, {
            type: 'array',
            expressions: x[2] || [],
        }) },
    {"name": "expr_array", "symbols": [(lexerAny.has("kw_array") ? {type: "kw_array"} : kw_array), "lparen", "selection", "rparen"], "postprocess":  x => track(x, {
            type: 'array select',
            select: unwrap(x[2]),
        }) },
    {"name": "expr_subarray$ebnf$1", "symbols": ["expr_subarray_items"], "postprocess": id},
    {"name": "expr_subarray$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_subarray", "symbols": [(lexerAny.has("lbracket") ? {type: "lbracket"} : lbracket), "expr_subarray$ebnf$1", (lexerAny.has("rbracket") ? {type: "rbracket"} : rbracket)], "postprocess": get(1)},
    {"name": "expr_subarray_items$macrocall$2", "symbols": ["expr_list_item"]},
    {"name": "expr_subarray_items$macrocall$1$ebnf$1", "symbols": []},
    {"name": "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "expr_subarray_items$macrocall$2"], "postprocess": last},
    {"name": "expr_subarray_items$macrocall$1$ebnf$1", "symbols": ["expr_subarray_items$macrocall$1$ebnf$1", "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "expr_subarray_items$macrocall$1", "symbols": ["expr_subarray_items$macrocall$2", "expr_subarray_items$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "expr_subarray_items", "symbols": ["expr_subarray_items$macrocall$1"], "postprocess": x => x[0].map(unwrap)},
    {"name": "expr_subarray_items$macrocall$4", "symbols": ["expr_subarray"]},
    {"name": "expr_subarray_items$macrocall$3$ebnf$1", "symbols": []},
    {"name": "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "expr_subarray_items$macrocall$4"], "postprocess": last},
    {"name": "expr_subarray_items$macrocall$3$ebnf$1", "symbols": ["expr_subarray_items$macrocall$3$ebnf$1", "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "expr_subarray_items$macrocall$3", "symbols": ["expr_subarray_items$macrocall$4", "expr_subarray_items$macrocall$3$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "expr_subarray_items", "symbols": ["expr_subarray_items$macrocall$3"], "postprocess":  (x: any) => {
            return x[0].map((v: any[]) => {
                return track(v, {
                    type: 'array',
                    expressions: v[0].map(unwrap),
                })
            })
        } },
    {"name": "expr_function_call$ebnf$1", "symbols": ["expr_list_raw"], "postprocess": id},
    {"name": "expr_function_call$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_function_call", "symbols": ["expr_fn_name", "lparen", "expr_function_call$ebnf$1", "rparen"], "postprocess":  x => track(x, {
            type: 'call',
            function: unwrap(x[0]),
            args: x[2] || [],
        }) },
    {"name": "expr_call$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)]},
    {"name": "expr_call$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_distinct") ? {type: "kw_distinct"} : kw_distinct)]},
    {"name": "expr_call$ebnf$1", "symbols": ["expr_call$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "expr_call$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_call$ebnf$2", "symbols": ["expr_list_raw"], "postprocess": id},
    {"name": "expr_call$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "expr_call$ebnf$3", "symbols": ["select_order_by"], "postprocess": id},
    {"name": "expr_call$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "expr_call$ebnf$4$subexpression$1", "symbols": ["kw_filter", "lparen", (lexerAny.has("kw_where") ? {type: "kw_where"} : kw_where), "expr", "rparen"], "postprocess": get(3)},
    {"name": "expr_call$ebnf$4", "symbols": ["expr_call$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "expr_call$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "expr_call$ebnf$5", "symbols": ["expr_call_within_group"], "postprocess": id},
    {"name": "expr_call$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "expr_call$ebnf$6", "symbols": ["expr_call_over"], "postprocess": id},
    {"name": "expr_call$ebnf$6", "symbols": [], "postprocess": () => null},
    {"name": "expr_call", "symbols": ["expr_fn_name", "lparen", "expr_call$ebnf$1", "expr_call$ebnf$2", "expr_call$ebnf$3", "rparen", "expr_call$ebnf$4", "expr_call$ebnf$5", "expr_call$ebnf$6"], "postprocess":  x => track(x, {
            type: 'call',
            function: unwrap(x[0]),
            ...x[2] && {distinct: toStr(x[2])},
            args: x[3] || [],
            ...x[4] && {orderBy: x[4]},
            ...x[6] && {filter: unwrap(x[6])},
            ...x[7] && {withinGroup: x[7]},
            ...x[8] && {over: unwrap(x[8])},
        }) },
    {"name": "expr_call_over$ebnf$1$subexpression$1", "symbols": ["kw_partition", "kw_by", "expr_list_raw"], "postprocess": last},
    {"name": "expr_call_over$ebnf$1", "symbols": ["expr_call_over$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "expr_call_over$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_call_over$ebnf$2", "symbols": ["select_order_by"], "postprocess": id},
    {"name": "expr_call_over$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "expr_call_over", "symbols": ["kw_over", "lparen", "expr_call_over$ebnf$1", "expr_call_over$ebnf$2", "rparen"], "postprocess":  x => track(x, {
            ...x[2] && { partitionBy: x[2] },
            ...x[3] && { orderBy: x[3] },
        }) },
    {"name": "expr_call_within_group$subexpression$1", "symbols": ["kw_within", (lexerAny.has("kw_group") ? {type: "kw_group"} : kw_group)]},
    {"name": "expr_call_within_group$subexpression$2", "symbols": [(lexerAny.has("kw_order") ? {type: "kw_order"} : kw_order), "kw_by"]},
    {"name": "expr_call_within_group", "symbols": ["expr_call_within_group$subexpression$1", "lparen", "expr_call_within_group$subexpression$2", "select_order_by_expr", "rparen"], "postprocess": x => track(x, x[3])},
    {"name": "expr_extract$subexpression$1", "symbols": ["word"], "postprocess": kw('extract')},
    {"name": "expr_extract", "symbols": ["expr_extract$subexpression$1", "lparen", "word", (lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from), "expr", "rparen"], "postprocess":  x => track(x, {
            type: 'extract',
            field: asName(x[2]),
            from: x[4],
        }) },
    {"name": "expr_primary", "symbols": ["float"], "postprocess": x => track(x, { type: 'numeric', value: unbox(x[0]) })},
    {"name": "expr_primary", "symbols": ["int"], "postprocess": x => track(x, { type: 'integer', value: unbox(x[0]) })},
    {"name": "expr_primary", "symbols": ["string"], "postprocess": x => track(x, { type: 'string', value: unbox(x[0]) })},
    {"name": "expr_primary", "symbols": [(lexerAny.has("kw_true") ? {type: "kw_true"} : kw_true)], "postprocess": x => track(x, { type: 'boolean', value: true })},
    {"name": "expr_primary", "symbols": [(lexerAny.has("kw_false") ? {type: "kw_false"} : kw_false)], "postprocess": x => track(x, { type: 'boolean', value: false })},
    {"name": "expr_primary", "symbols": [(lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null)], "postprocess": x => track(x, { type: 'null' })},
    {"name": "expr_primary", "symbols": ["value_keyword"], "postprocess": x => track(x, {type: 'keyword', keyword: toStr(x) })},
    {"name": "expr_primary", "symbols": [(lexerAny.has("qparam") ? {type: "qparam"} : qparam)], "postprocess": x => track(x, { type: 'parameter', name: toStr(x[0]) })},
    {"name": "expr_primary", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)], "postprocess": x => track(x, { type: 'default'})},
    {"name": "ops_like", "symbols": ["ops_like_keywors"]},
    {"name": "ops_like", "symbols": ["ops_like_operators"]},
    {"name": "ops_like_keywors$ebnf$1", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)], "postprocess": id},
    {"name": "ops_like_keywors$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "ops_like_keywors$subexpression$1", "symbols": [(lexerAny.has("kw_like") ? {type: "kw_like"} : kw_like)]},
    {"name": "ops_like_keywors$subexpression$1", "symbols": [(lexerAny.has("kw_ilike") ? {type: "kw_ilike"} : kw_ilike)]},
    {"name": "ops_like_keywors", "symbols": ["ops_like_keywors$ebnf$1", "ops_like_keywors$subexpression$1"]},
    {"name": "ops_like_operators$subexpression$1", "symbols": [(lexerAny.has("op_like") ? {type: "op_like"} : op_like)], "postprocess": () => 'LIKE'},
    {"name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$1"]},
    {"name": "ops_like_operators$subexpression$2", "symbols": [(lexerAny.has("op_ilike") ? {type: "op_ilike"} : op_ilike)], "postprocess": () => 'ILIKE'},
    {"name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$2"]},
    {"name": "ops_like_operators$subexpression$3", "symbols": [(lexerAny.has("op_not_like") ? {type: "op_not_like"} : op_not_like)], "postprocess": () => 'NOT LIKE'},
    {"name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$3"]},
    {"name": "ops_like_operators$subexpression$4", "symbols": [(lexerAny.has("op_not_ilike") ? {type: "op_not_ilike"} : op_not_ilike)], "postprocess": () => 'NOT ILIKE'},
    {"name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$4"]},
    {"name": "ops_in$ebnf$1", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)], "postprocess": id},
    {"name": "ops_in$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "ops_in", "symbols": ["ops_in$ebnf$1", (lexerAny.has("kw_in") ? {type: "kw_in"} : kw_in)]},
    {"name": "ops_between$ebnf$1", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)], "postprocess": id},
    {"name": "ops_between$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "ops_between", "symbols": ["ops_between$ebnf$1", "kw_between"]},
    {"name": "ops_member$subexpression$1", "symbols": [(lexerAny.has("op_member") ? {type: "op_member"} : op_member)]},
    {"name": "ops_member$subexpression$1", "symbols": [(lexerAny.has("op_membertext") ? {type: "op_membertext"} : op_membertext)]},
    {"name": "ops_member", "symbols": ["ops_member$subexpression$1"], "postprocess": x => unwrap(x)?.value},
    {"name": "expr_list_item", "symbols": ["expr_or_select"], "postprocess": unwrap},
    {"name": "expr_list_item", "symbols": ["expr_star"], "postprocess": unwrap},
    {"name": "expr_list_raw$macrocall$2", "symbols": ["expr_list_item"]},
    {"name": "expr_list_raw$macrocall$1$ebnf$1", "symbols": []},
    {"name": "expr_list_raw$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "expr_list_raw$macrocall$2"], "postprocess": last},
    {"name": "expr_list_raw$macrocall$1$ebnf$1", "symbols": ["expr_list_raw$macrocall$1$ebnf$1", "expr_list_raw$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "expr_list_raw$macrocall$1", "symbols": ["expr_list_raw$macrocall$2", "expr_list_raw$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "expr_list_raw", "symbols": ["expr_list_raw$macrocall$1"], "postprocess": ([x]) => x.map(unwrap)},
    {"name": "expr_list_raw_many$macrocall$2", "symbols": ["expr_list_item"]},
    {"name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "expr_list_raw_many$macrocall$2"], "postprocess": last},
    {"name": "expr_list_raw_many$macrocall$1$ebnf$1", "symbols": ["expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1"]},
    {"name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "expr_list_raw_many$macrocall$2"], "postprocess": last},
    {"name": "expr_list_raw_many$macrocall$1$ebnf$1", "symbols": ["expr_list_raw_many$macrocall$1$ebnf$1", "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "expr_list_raw_many$macrocall$1", "symbols": ["expr_list_raw_many$macrocall$2", "expr_list_raw_many$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "expr_list_raw_many", "symbols": ["expr_list_raw_many$macrocall$1"], "postprocess": ([x]) => x.map(unwrap)},
    {"name": "expr_or_select", "symbols": ["expr_nostar"], "postprocess": unwrap},
    {"name": "expr_or_select", "symbols": ["selection"], "postprocess": unwrap},
    {"name": "expr_list_many", "symbols": ["expr_list_raw_many"], "postprocess":  x => track(x, {
            type: 'list',
            expressions: x[0],
        }) },
    {"name": "expr_case$ebnf$1", "symbols": ["expr_nostar"], "postprocess": id},
    {"name": "expr_case$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_case$ebnf$2", "symbols": []},
    {"name": "expr_case$ebnf$2", "symbols": ["expr_case$ebnf$2", "expr_case_whens"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "expr_case$ebnf$3", "symbols": ["expr_case_else"], "postprocess": id},
    {"name": "expr_case$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "expr_case", "symbols": [(lexerAny.has("kw_case") ? {type: "kw_case"} : kw_case), "expr_case$ebnf$1", "expr_case$ebnf$2", "expr_case$ebnf$3", (lexerAny.has("kw_end") ? {type: "kw_end"} : kw_end)], "postprocess":  x => track(x, {
            type: 'case',
            value: x[1],
            whens: x[2],
            else: x[3],
        }) },
    {"name": "expr_case_whens", "symbols": [(lexerAny.has("kw_when") ? {type: "kw_when"} : kw_when), "expr_nostar", (lexerAny.has("kw_then") ? {type: "kw_then"} : kw_then), "expr_nostar"], "postprocess":  x => track(x, {
            when: x[1],
            value: x[3],
        }) },
    {"name": "expr_case_else", "symbols": [(lexerAny.has("kw_else") ? {type: "kw_else"} : kw_else), "expr_nostar"], "postprocess": last},
    {"name": "expr_fn_name$subexpression$1$ebnf$1$subexpression$1", "symbols": ["word", (lexerAny.has("dot") ? {type: "dot"} : dot)]},
    {"name": "expr_fn_name$subexpression$1$ebnf$1", "symbols": ["expr_fn_name$subexpression$1$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "expr_fn_name$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "expr_fn_name$subexpression$1", "symbols": ["expr_fn_name$subexpression$1$ebnf$1", "word_or_keyword"], "postprocess":  x => track(x, {
            name: unbox(unwrap(x[1])),
            ...x[0] && { schema: toStr(x[0][0]) },
        })  },
    {"name": "expr_fn_name", "symbols": ["expr_fn_name$subexpression$1"]},
    {"name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [(lexerAny.has("kw_any") ? {type: "kw_any"} : kw_any)]},
    {"name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [(lexerAny.has("kw_some") ? {type: "kw_some"} : kw_some)]},
    {"name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)]},
    {"name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [(lexerAny.has("kw_left") ? {type: "kw_left"} : kw_left)]},
    {"name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [(lexerAny.has("kw_right") ? {type: "kw_right"} : kw_right)]},
    {"name": "expr_fn_name$subexpression$2", "symbols": ["expr_fn_name$subexpression$2$subexpression$1"], "postprocess":  x => track(x, {
            name: toStr(unwrap(x)),
        })},
    {"name": "expr_fn_name", "symbols": ["expr_fn_name$subexpression$2"]},
    {"name": "word_or_keyword", "symbols": ["word"]},
    {"name": "word_or_keyword", "symbols": ["value_keyword"], "postprocess": x => box(x, toStr(x))},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_catalog") ? {type: "kw_current_catalog"} : kw_current_catalog)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_date") ? {type: "kw_current_date"} : kw_current_date)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_role") ? {type: "kw_current_role"} : kw_current_role)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_schema") ? {type: "kw_current_schema"} : kw_current_schema)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_timestamp") ? {type: "kw_current_timestamp"} : kw_current_timestamp)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_time") ? {type: "kw_current_time"} : kw_current_time)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_localtimestamp") ? {type: "kw_localtimestamp"} : kw_localtimestamp)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_localtime") ? {type: "kw_localtime"} : kw_localtime)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_session_user") ? {type: "kw_session_user"} : kw_session_user)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_user") ? {type: "kw_user"} : kw_user)]},
    {"name": "value_keyword", "symbols": [(lexerAny.has("kw_current_user") ? {type: "kw_current_user"} : kw_current_user)]},
    {"name": "expr_special_calls", "symbols": ["spe_overlay"]},
    {"name": "expr_special_calls", "symbols": ["spe_substring"]},
    {"name": "spe_overlay$subexpression$1", "symbols": ["word"], "postprocess": kw('overlay')},
    {"name": "spe_overlay$subexpression$2", "symbols": [(lexerAny.has("lparen") ? {type: "lparen"} : lparen), "expr_nostar"]},
    {"name": "spe_overlay$subexpression$3", "symbols": [(lexerAny.has("kw_placing") ? {type: "kw_placing"} : kw_placing), "expr_nostar"]},
    {"name": "spe_overlay$subexpression$4", "symbols": [(lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from), "expr_nostar"]},
    {"name": "spe_overlay$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_for") ? {type: "kw_for"} : kw_for), "expr_nostar"]},
    {"name": "spe_overlay$ebnf$1", "symbols": ["spe_overlay$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "spe_overlay$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "spe_overlay", "symbols": ["spe_overlay$subexpression$1", "spe_overlay$subexpression$2", "spe_overlay$subexpression$3", "spe_overlay$subexpression$4", "spe_overlay$ebnf$1", (lexerAny.has("rparen") ? {type: "rparen"} : rparen)], "postprocess":  x => track(x, {
            type: 'overlay',
            value: x[1][1],
            placing: x[2][1],
            from: x[3][1],
            ...x[4] && {for: x[4][1]},
        }) },
    {"name": "spe_substring$subexpression$1", "symbols": ["word"], "postprocess": kw('substring')},
    {"name": "spe_substring$subexpression$2", "symbols": [(lexerAny.has("lparen") ? {type: "lparen"} : lparen), "expr_nostar"]},
    {"name": "spe_substring$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from), "expr_nostar"]},
    {"name": "spe_substring$ebnf$1", "symbols": ["spe_substring$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "spe_substring$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "spe_substring$ebnf$2$subexpression$1", "symbols": [(lexerAny.has("kw_for") ? {type: "kw_for"} : kw_for), "expr_nostar"]},
    {"name": "spe_substring$ebnf$2", "symbols": ["spe_substring$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "spe_substring$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "spe_substring", "symbols": ["spe_substring$subexpression$1", "spe_substring$subexpression$2", "spe_substring$ebnf$1", "spe_substring$ebnf$2", (lexerAny.has("rparen") ? {type: "rparen"} : rparen)], "postprocess":  x => track(x, {
            type: 'substring',
            value: x[1][1],
            ...x[2] && {from: x[2][1]},
            ...x[3] && {for: x[3][1]},
        }) },
    {"name": "various_binaries", "symbols": ["kw_at", "kw_time", "kw_zone"], "postprocess": () => 'AT TIME ZONE'},
    {"name": "createtable_statement$ebnf$1", "symbols": ["createtable_modifiers"], "postprocess": id},
    {"name": "createtable_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createtable_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "createtable_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "createtable_statement$ebnf$3", "symbols": ["createtable_opts"], "postprocess": id},
    {"name": "createtable_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "createtable_statement", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "createtable_statement$ebnf$1", (lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table), "createtable_statement$ebnf$2", "qname", "lparen", "createtable_declarationlist", "rparen", "createtable_statement$ebnf$3"], "postprocess":  x => {
        
            const cols = x[6].filter((v: any) => 'kind' in v);
            const constraints = x[6].filter((v: any) => !('kind' in v));
        
            return track(x, {
                type: 'create table',
                ... !!x[3] ? { ifNotExists: true } : {},
                name: x[4],
                columns: cols,
                ...unwrap(x[1]),
                ...constraints.length ? { constraints } : {},
                ...last(x),
            });
        } },
    {"name": "createtable_modifiers", "symbols": ["kw_unlogged"], "postprocess": x => x[0] ? { unlogged: true } : {}},
    {"name": "createtable_modifiers", "symbols": ["m_locglob"]},
    {"name": "createtable_modifiers", "symbols": ["m_tmp"]},
    {"name": "createtable_modifiers", "symbols": ["m_locglob", "m_tmp"], "postprocess": ([a, b]) => ({...a, ...b})},
    {"name": "m_locglob$subexpression$1", "symbols": ["kw_local"]},
    {"name": "m_locglob$subexpression$1", "symbols": ["kw_global"]},
    {"name": "m_locglob", "symbols": ["m_locglob$subexpression$1"], "postprocess": x => ({ locality: toStr(x)})},
    {"name": "m_tmp$subexpression$1", "symbols": ["kw_temp"]},
    {"name": "m_tmp$subexpression$1", "symbols": ["kw_temporary"]},
    {"name": "m_tmp", "symbols": ["m_tmp$subexpression$1"], "postprocess": x => ({ temporary: true})},
    {"name": "createtable_declarationlist$ebnf$1", "symbols": []},
    {"name": "createtable_declarationlist$ebnf$1$subexpression$1", "symbols": ["comma", "createtable_declaration"], "postprocess": last},
    {"name": "createtable_declarationlist$ebnf$1", "symbols": ["createtable_declarationlist$ebnf$1", "createtable_declarationlist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtable_declarationlist", "symbols": ["createtable_declaration", "createtable_declarationlist$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "createtable_declaration$subexpression$1", "symbols": ["createtable_constraint"]},
    {"name": "createtable_declaration$subexpression$1", "symbols": ["createtable_column"]},
    {"name": "createtable_declaration$subexpression$1", "symbols": ["createtable_like"]},
    {"name": "createtable_declaration", "symbols": ["createtable_declaration$subexpression$1"], "postprocess": unwrap},
    {"name": "createtable_constraint$macrocall$2", "symbols": ["createtable_constraint_def"]},
    {"name": "createtable_constraint$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_constraint") ? {type: "kw_constraint"} : kw_constraint), "word"]},
    {"name": "createtable_constraint$macrocall$1$ebnf$1", "symbols": ["createtable_constraint$macrocall$1$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "createtable_constraint$macrocall$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createtable_constraint$macrocall$1", "symbols": ["createtable_constraint$macrocall$1$ebnf$1", "createtable_constraint$macrocall$2"], "postprocess":  x => {
            const name = x[0] && asName(x[0][1]);
            if (!name) {
                return track(x, unwrap(x[1]));
            }
            return track(x, {
                constraintName: name,
                ...unwrap(x[1]),
            })
        } },
    {"name": "createtable_constraint", "symbols": ["createtable_constraint$macrocall$1"], "postprocess": unwrap},
    {"name": "createtable_constraint_def", "symbols": ["createtable_constraint_def_unique"]},
    {"name": "createtable_constraint_def", "symbols": ["createtable_constraint_def_check"]},
    {"name": "createtable_constraint_def", "symbols": ["createtable_constraint_foreignkey"]},
    {"name": "createtable_constraint_def_unique$subexpression$1", "symbols": [(lexerAny.has("kw_unique") ? {type: "kw_unique"} : kw_unique)]},
    {"name": "createtable_constraint_def_unique$subexpression$1", "symbols": ["kw_primary_key"]},
    {"name": "createtable_constraint_def_unique", "symbols": ["createtable_constraint_def_unique$subexpression$1", "lparen", "createtable_collist", "rparen"], "postprocess":  x => track(x, {
            type: toStr(x[0], ' '),
            columns: x[2].map(asName),
        }) },
    {"name": "createtable_constraint_def_check", "symbols": [(lexerAny.has("kw_check") ? {type: "kw_check"} : kw_check), "expr_paren"], "postprocess":  x => track(x, {
            type: 'check',
            expr: unwrap(x[1]),
        }) },
    {"name": "createtable_constraint_foreignkey", "symbols": [(lexerAny.has("kw_foreign") ? {type: "kw_foreign"} : kw_foreign), "kw_key", "collist_paren", "createtable_references"], "postprocess":  (x: any[]) => {
            return track(x, {
                type: 'foreign key',
                localColumns: x[2].map(asName),
                ...x[3],
            });
        } },
    {"name": "createtable_references$ebnf$1", "symbols": []},
    {"name": "createtable_references$ebnf$1", "symbols": ["createtable_references$ebnf$1", "createtable_constraint_foreignkey_onsometing"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtable_references", "symbols": [(lexerAny.has("kw_references") ? {type: "kw_references"} : kw_references), "table_ref", "collist_paren", "createtable_references$ebnf$1"], "postprocess":  (x: any[]) => {
            return track(x, {
                foreignTable: unwrap(x[1]),
                foreignColumns: x[2].map(asName),
                ...x[3].reduce((a: any, b: any) => ({...a, ...b}), {}),
            });
        } },
    {"name": "createtable_constraint_foreignkey_onsometing", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "kw_delete", "createtable_constraint_on_action"], "postprocess": x => track(x, {onDelete:  last(x)})},
    {"name": "createtable_constraint_foreignkey_onsometing", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "kw_update", "createtable_constraint_on_action"], "postprocess": x => track(x, {onUpdate: last(x)})},
    {"name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": [(lexerAny.has("kw_full") ? {type: "kw_full"} : kw_full)]},
    {"name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": ["kw_partial"]},
    {"name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": ["kw_simple"]},
    {"name": "createtable_constraint_foreignkey_onsometing", "symbols": ["kw_match", "createtable_constraint_foreignkey_onsometing$subexpression$1"], "postprocess": x => track(x, {match: toStr(last(x))})},
    {"name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_cascade"]},
    {"name": "createtable_constraint_on_action$subexpression$1$subexpression$1", "symbols": ["kw_no", "kw_action"]},
    {"name": "createtable_constraint_on_action$subexpression$1", "symbols": ["createtable_constraint_on_action$subexpression$1$subexpression$1"]},
    {"name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_restrict"]},
    {"name": "createtable_constraint_on_action$subexpression$1$subexpression$2", "symbols": [(lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null)]},
    {"name": "createtable_constraint_on_action$subexpression$1$subexpression$2", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)]},
    {"name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_set", "createtable_constraint_on_action$subexpression$1$subexpression$2"]},
    {"name": "createtable_constraint_on_action", "symbols": ["createtable_constraint_on_action$subexpression$1"], "postprocess": x => toStr(x, ' ')},
    {"name": "createtable_collist$ebnf$1", "symbols": []},
    {"name": "createtable_collist$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last},
    {"name": "createtable_collist$ebnf$1", "symbols": ["createtable_collist$ebnf$1", "createtable_collist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtable_collist", "symbols": ["ident", "createtable_collist$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "createtable_column$ebnf$1", "symbols": ["createtable_collate"], "postprocess": id},
    {"name": "createtable_column$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createtable_column$ebnf$2", "symbols": []},
    {"name": "createtable_column$ebnf$2", "symbols": ["createtable_column$ebnf$2", "createtable_column_constraint"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtable_column", "symbols": ["word", "data_type", "createtable_column$ebnf$1", "createtable_column$ebnf$2"], "postprocess":  x => {
            return track(x, {
                kind: 'column',
                name: asName(x[0]),
                dataType: x[1],
                ...x[2] ? { collate: x[2][1] }: {},
                ...x[3] && x[3].length ? { constraints: x[3] }: {},
            })
        } },
    {"name": "createtable_like$ebnf$1", "symbols": []},
    {"name": "createtable_like$ebnf$1", "symbols": ["createtable_like$ebnf$1", "createtable_like_opt"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtable_like", "symbols": [(lexerAny.has("kw_like") ? {type: "kw_like"} : kw_like), "qname", "createtable_like$ebnf$1"], "postprocess":  x => track(x, {
                kind: 'like table',
                like: x[1],
                options: x[2],
        }) },
    {"name": "createtable_like_opt$subexpression$1", "symbols": ["kw_including"]},
    {"name": "createtable_like_opt$subexpression$1", "symbols": ["kw_excluding"]},
    {"name": "createtable_like_opt", "symbols": ["createtable_like_opt$subexpression$1", "createtable_like_opt_val"], "postprocess":  x => track(x, {
            verb: toStr(x[0]),
            option: toStr(x[1]),
        }) },
    {"name": "createtable_like_opt_val", "symbols": ["word"], "postprocess": anyKw('defaults', 'constraints', 'indexes', 'storage', 'comments')},
    {"name": "createtable_like_opt_val", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)]},
    {"name": "createtable_column_constraint$macrocall$2", "symbols": ["createtable_column_constraint_def"]},
    {"name": "createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_constraint") ? {type: "kw_constraint"} : kw_constraint), "word"]},
    {"name": "createtable_column_constraint$macrocall$1$ebnf$1", "symbols": ["createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "createtable_column_constraint$macrocall$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createtable_column_constraint$macrocall$1", "symbols": ["createtable_column_constraint$macrocall$1$ebnf$1", "createtable_column_constraint$macrocall$2"], "postprocess":  x => {
            const name = x[0] && asName(x[0][1]);
            if (!name) {
                return track(x, unwrap(x[1]));
            }
            return track(x, {
                constraintName: name,
                ...unwrap(x[1]),
            })
        } },
    {"name": "createtable_column_constraint", "symbols": ["createtable_column_constraint$macrocall$1"], "postprocess": unwrap},
    {"name": "createtable_column_constraint_def", "symbols": [(lexerAny.has("kw_unique") ? {type: "kw_unique"} : kw_unique)], "postprocess": x => track(x, { type: 'unique' })},
    {"name": "createtable_column_constraint_def", "symbols": ["kw_primary_key"], "postprocess": x => track(x, { type: 'primary key' })},
    {"name": "createtable_column_constraint_def", "symbols": ["kw_not_null"], "postprocess": x => track(x, { type: 'not null' })},
    {"name": "createtable_column_constraint_def", "symbols": [(lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null)], "postprocess": x => track(x, { type: 'null' })},
    {"name": "createtable_column_constraint_def", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default), "expr"], "postprocess": x => track(x, { type: 'default', default: unwrap(x[1]) })},
    {"name": "createtable_column_constraint_def", "symbols": [(lexerAny.has("kw_check") ? {type: "kw_check"} : kw_check), "expr_paren"], "postprocess": x => track(x, { type: 'check', expr: unwrap(x[1]) })},
    {"name": "createtable_column_constraint_def", "symbols": ["createtable_references"], "postprocess": x => track(x, { type: 'reference', ...unwrap(x) })},
    {"name": "createtable_column_constraint_def", "symbols": ["altercol_generated"]},
    {"name": "createtable_collate", "symbols": [(lexerAny.has("kw_collate") ? {type: "kw_collate"} : kw_collate), "qualified_name"]},
    {"name": "createtable_opts$subexpression$1", "symbols": ["word"], "postprocess": kw('inherits')},
    {"name": "createtable_opts$macrocall$2", "symbols": ["qname"]},
    {"name": "createtable_opts$macrocall$1$ebnf$1", "symbols": []},
    {"name": "createtable_opts$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "createtable_opts$macrocall$2"], "postprocess": last},
    {"name": "createtable_opts$macrocall$1$ebnf$1", "symbols": ["createtable_opts$macrocall$1$ebnf$1", "createtable_opts$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtable_opts$macrocall$1", "symbols": ["createtable_opts$macrocall$2", "createtable_opts$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "createtable_opts", "symbols": ["createtable_opts$subexpression$1", "lparen", "createtable_opts$macrocall$1", "rparen"], "postprocess": x => track(x, { inherits: x[2] })},
    {"name": "createindex_statement$ebnf$1", "symbols": [(lexerAny.has("kw_unique") ? {type: "kw_unique"} : kw_unique)], "postprocess": id},
    {"name": "createindex_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$2", "symbols": [(lexerAny.has("kw_concurrently") ? {type: "kw_concurrently"} : kw_concurrently)], "postprocess": id},
    {"name": "createindex_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$3", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "createindex_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$4", "symbols": ["word"], "postprocess": id},
    {"name": "createindex_statement$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$5$subexpression$1", "symbols": [(lexerAny.has("kw_using") ? {type: "kw_using"} : kw_using), "ident"], "postprocess": last},
    {"name": "createindex_statement$ebnf$5", "symbols": ["createindex_statement$ebnf$5$subexpression$1"], "postprocess": id},
    {"name": "createindex_statement$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$6", "symbols": ["createindex_with"], "postprocess": id},
    {"name": "createindex_statement$ebnf$6", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$7", "symbols": ["createindex_tblspace"], "postprocess": id},
    {"name": "createindex_statement$ebnf$7", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement$ebnf$8", "symbols": ["createindex_predicate"], "postprocess": id},
    {"name": "createindex_statement$ebnf$8", "symbols": [], "postprocess": () => null},
    {"name": "createindex_statement", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "createindex_statement$ebnf$1", "kw_index", "createindex_statement$ebnf$2", "createindex_statement$ebnf$3", "createindex_statement$ebnf$4", (lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "table_ref", "createindex_statement$ebnf$5", "lparen", "createindex_expressions", "rparen", "createindex_statement$ebnf$6", "createindex_statement$ebnf$7", "createindex_statement$ebnf$8"], "postprocess":  x => track(x, {
            type: 'create index',
            ...x[1] && { unique: true },
            ...x[3] && { concurrently: true },
            ...x[4] && { ifNotExists: true },
            ...x[5] && { indexName: asName(x[5]) },
            table: x[7],
            ...x[8] && { using: asName(x[8]) },
            expressions: x[10],
            ...x[12] && { with: x[12] },
            ...x[13] && { tablespace: unwrap(x[13]) },
            ...x[14] && { where: unwrap(x[14]) },
        }) },
    {"name": "createindex_expressions$ebnf$1", "symbols": []},
    {"name": "createindex_expressions$ebnf$1$subexpression$1", "symbols": ["comma", "createindex_expression"], "postprocess": last},
    {"name": "createindex_expressions$ebnf$1", "symbols": ["createindex_expressions$ebnf$1", "createindex_expressions$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createindex_expressions", "symbols": ["createindex_expression", "createindex_expressions$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "createindex_expression$subexpression$1", "symbols": ["expr_basic"]},
    {"name": "createindex_expression$subexpression$1", "symbols": ["expr_paren"]},
    {"name": "createindex_expression$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_collate") ? {type: "kw_collate"} : kw_collate), "qualified_name"], "postprocess": last},
    {"name": "createindex_expression$ebnf$1", "symbols": ["createindex_expression$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "createindex_expression$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createindex_expression$ebnf$2", "symbols": ["qualified_name"], "postprocess": id},
    {"name": "createindex_expression$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "createindex_expression$ebnf$3$subexpression$1", "symbols": [(lexerAny.has("kw_asc") ? {type: "kw_asc"} : kw_asc)]},
    {"name": "createindex_expression$ebnf$3$subexpression$1", "symbols": [(lexerAny.has("kw_desc") ? {type: "kw_desc"} : kw_desc)]},
    {"name": "createindex_expression$ebnf$3", "symbols": ["createindex_expression$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "createindex_expression$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1", "symbols": ["kw_first"]},
    {"name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1", "symbols": ["kw_last"]},
    {"name": "createindex_expression$ebnf$4$subexpression$1", "symbols": ["kw_nulls", "createindex_expression$ebnf$4$subexpression$1$subexpression$1"], "postprocess": last},
    {"name": "createindex_expression$ebnf$4", "symbols": ["createindex_expression$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "createindex_expression$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "createindex_expression", "symbols": ["createindex_expression$subexpression$1", "createindex_expression$ebnf$1", "createindex_expression$ebnf$2", "createindex_expression$ebnf$3", "createindex_expression$ebnf$4"], "postprocess":  x => track(x, {
            expression: unwrap(x[0]),
            ...x[1] && { collate: unwrap(x[1]) },
            ...x[2] && { opclass: unwrap(x[2]) },
            ...x[3] && { order: unwrap(x[3]).value },
            ...x[4] && { nulls: unwrap(x[4]) },
        }) },
    {"name": "createindex_predicate", "symbols": [(lexerAny.has("kw_where") ? {type: "kw_where"} : kw_where), "expr"], "postprocess": last},
    {"name": "createindex_with$macrocall$2", "symbols": ["createindex_with_item"]},
    {"name": "createindex_with$macrocall$1$ebnf$1", "symbols": []},
    {"name": "createindex_with$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "createindex_with$macrocall$2"], "postprocess": last},
    {"name": "createindex_with$macrocall$1$ebnf$1", "symbols": ["createindex_with$macrocall$1$ebnf$1", "createindex_with$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createindex_with$macrocall$1", "symbols": ["createindex_with$macrocall$2", "createindex_with$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "createindex_with", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "lparen", "createindex_with$macrocall$1", "rparen"], "postprocess": get(2)},
    {"name": "createindex_with_item$subexpression$1", "symbols": ["string"]},
    {"name": "createindex_with_item$subexpression$1", "symbols": ["int"]},
    {"name": "createindex_with_item", "symbols": ["ident", (lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq), "createindex_with_item$subexpression$1"], "postprocess": x => track(x, { parameter: toStr(x[0]), value: unwrap(x[2]).toString() })},
    {"name": "createindex_tblspace", "symbols": ["kw_tablespace", "ident"], "postprocess": last},
    {"name": "createextension_statement$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "createextension_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createextension_statement$ebnf$2", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with)], "postprocess": id},
    {"name": "createextension_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "createextension_statement$ebnf$3$subexpression$1", "symbols": ["kw_schema", "word"], "postprocess": last},
    {"name": "createextension_statement$ebnf$3", "symbols": ["createextension_statement$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "createextension_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "createextension_statement$ebnf$4$subexpression$1", "symbols": ["kw_version", "string"], "postprocess": last},
    {"name": "createextension_statement$ebnf$4", "symbols": ["createextension_statement$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "createextension_statement$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "createextension_statement$ebnf$5$subexpression$1", "symbols": [(lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from), "string"], "postprocess": last},
    {"name": "createextension_statement$ebnf$5", "symbols": ["createextension_statement$ebnf$5$subexpression$1"], "postprocess": id},
    {"name": "createextension_statement$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "createextension_statement", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "kw_extension", "createextension_statement$ebnf$1", "word", "createextension_statement$ebnf$2", "createextension_statement$ebnf$3", "createextension_statement$ebnf$4", "createextension_statement$ebnf$5"], "postprocess":  x => track(x, {
            type: 'create extension',
            ... !!x[2] ? { ifNotExists: true } : {},
            extension: asName(x[3]),
            ... !!x[5] ? { schema: asName(x[5]) } : {},
            ... !!x[6] ? { version: asLit(x[6]) } : {},
            ... !!x[7] ? { from: asLit(x[7]) } : {},
        }) },
    {"name": "simplestatements_all", "symbols": ["simplestatements_start_transaction"]},
    {"name": "simplestatements_all", "symbols": ["simplestatements_commit"]},
    {"name": "simplestatements_all", "symbols": ["simplestatements_rollback"]},
    {"name": "simplestatements_all", "symbols": ["simplestatements_tablespace"]},
    {"name": "simplestatements_all", "symbols": ["simplestatements_set"]},
    {"name": "simplestatements_all", "symbols": ["simplestatements_show"]},
    {"name": "simplestatements_all", "symbols": ["simplestatements_begin"]},
    {"name": "simplestatements_start_transaction$subexpression$1", "symbols": ["kw_start", "kw_transaction"]},
    {"name": "simplestatements_start_transaction", "symbols": ["simplestatements_start_transaction$subexpression$1"], "postprocess": x => track(x, { type: 'start transaction' })},
    {"name": "simplestatements_commit", "symbols": ["kw_commit"], "postprocess": x => track(x, { type: 'commit' })},
    {"name": "simplestatements_rollback", "symbols": ["kw_rollback"], "postprocess": x => track(x, { type: 'rollback' })},
    {"name": "simplestatements_tablespace", "symbols": ["kw_tablespace", "word"], "postprocess": x => track(x, {
           type: 'tablespace',
           tablespace: asName(x[1]),
        }) },
    {"name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_simple"]},
    {"name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_timezone"]},
    {"name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_names"]},
    {"name": "simplestatements_set", "symbols": ["kw_set", "simplestatements_set$subexpression$1"], "postprocess": last},
    {"name": "simplestatements_set_timezone", "symbols": ["kw_time", "kw_zone", "simplestatements_set_timezone_val"], "postprocess": x => track(x, { type: 'set timezone', to: x[2] })},
    {"name": "simplestatements_set_timezone_val$subexpression$1", "symbols": ["string"]},
    {"name": "simplestatements_set_timezone_val$subexpression$1", "symbols": ["int"]},
    {"name": "simplestatements_set_timezone_val", "symbols": ["simplestatements_set_timezone_val$subexpression$1"], "postprocess": x => track(x, { type: 'value', value: unwrap(x[0]) })},
    {"name": "simplestatements_set_timezone_val", "symbols": ["kw_local"], "postprocess": x => track(x, { type: 'local'})},
    {"name": "simplestatements_set_timezone_val", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)], "postprocess": x => track(x, { type: 'default'})},
    {"name": "simplestatements_set_timezone_val", "symbols": ["kw_interval", "string", "kw_hour", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "kw_minute"], "postprocess": x => track(x, { type: 'interval', value: unbox(x[1]) })},
    {"name": "simplestatements_set_names", "symbols": ["kw_names", "simplestatements_set_names_val"], "postprocess": x => track(x, { type: 'set names', to: x[1] })},
    {"name": "simplestatements_set_names_val$subexpression$1", "symbols": ["string"]},
    {"name": "simplestatements_set_names_val", "symbols": ["simplestatements_set_names_val$subexpression$1"], "postprocess": x => track(x, { type: 'value', value: unwrap(x[0]) })},
    {"name": "simplestatements_set_simple$ebnf$1$subexpression$1", "symbols": ["kw_local"]},
    {"name": "simplestatements_set_simple$ebnf$1$subexpression$1", "symbols": ["kw_session"]},
    {"name": "simplestatements_set_simple$ebnf$1", "symbols": ["simplestatements_set_simple$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "simplestatements_set_simple$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "simplestatements_set_simple$subexpression$1", "symbols": [(lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq)]},
    {"name": "simplestatements_set_simple$subexpression$1", "symbols": [(lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to)]},
    {"name": "simplestatements_set_simple", "symbols": ["simplestatements_set_simple$ebnf$1", "ident", "simplestatements_set_simple$subexpression$1", "simplestatements_set_val"], "postprocess":  x  => track(x, {
            type: 'set',
            variable: asName(x[1]),
            scope: unwrap(x[0])?.toLowerCase(),
            set: unbox(x[3]),
        }) },
    {"name": "simplestatements_set_val", "symbols": ["simplestatements_set_val_raw"], "postprocess": unwrap},
    {"name": "simplestatements_set_val", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)], "postprocess": x => track(x, {type: 'default'})},
    {"name": "simplestatements_set_val$ebnf$1$subexpression$1", "symbols": ["comma", "simplestatements_set_val_raw"]},
    {"name": "simplestatements_set_val$ebnf$1", "symbols": ["simplestatements_set_val$ebnf$1$subexpression$1"]},
    {"name": "simplestatements_set_val$ebnf$1$subexpression$2", "symbols": ["comma", "simplestatements_set_val_raw"]},
    {"name": "simplestatements_set_val$ebnf$1", "symbols": ["simplestatements_set_val$ebnf$1", "simplestatements_set_val$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "simplestatements_set_val", "symbols": ["simplestatements_set_val_raw", "simplestatements_set_val$ebnf$1"], "postprocess":  x => track(x, {
                type: 'list',
                values: [x[0], ...(x[1] || [])]
        }) },
    {"name": "simplestatements_set_val_raw$subexpression$1", "symbols": ["string"]},
    {"name": "simplestatements_set_val_raw$subexpression$1", "symbols": ["int"]},
    {"name": "simplestatements_set_val_raw", "symbols": ["simplestatements_set_val_raw$subexpression$1"], "postprocess": x => track(x, { type: 'value', value: unwrap(x) })},
    {"name": "simplestatements_set_val_raw$subexpression$2", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)]},
    {"name": "simplestatements_set_val_raw$subexpression$2", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on)]},
    {"name": "simplestatements_set_val_raw$subexpression$2", "symbols": [(lexerAny.has("kw_true") ? {type: "kw_true"} : kw_true)]},
    {"name": "simplestatements_set_val_raw$subexpression$2", "symbols": [(lexerAny.has("kw_false") ? {type: "kw_false"} : kw_false)]},
    {"name": "simplestatements_set_val_raw", "symbols": ["simplestatements_set_val_raw$subexpression$2"], "postprocess": x => track(x, { type: 'identifier', name: unwrap(x).value })},
    {"name": "simplestatements_set_val_raw", "symbols": [(lexerAny.has("quoted_word") ? {type: "quoted_word"} : quoted_word)], "postprocess": x => track(x, { type: 'identifier', doubleQuoted: true, name: unwrap(x).value })},
    {"name": "simplestatements_show", "symbols": ["kw_show", "ident"], "postprocess": x => track(x, { type: 'show', variable: asName(x[1]) })},
    {"name": "create_schema$subexpression$1", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "kw_schema"]},
    {"name": "create_schema$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "create_schema$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_schema", "symbols": ["create_schema$subexpression$1", "create_schema$ebnf$1", "ident"], "postprocess":  x => track(x, {
            type: 'create schema',
            name: asName(x[2]),
            ... !!x[1] ? { ifNotExists: true } : {},
        }) },
    {"name": "raise_statement$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": anyKw('debug', 'log', 'info', 'notice', 'warning', 'exception')},
    {"name": "raise_statement$ebnf$1", "symbols": ["raise_statement$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "raise_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "raise_statement$ebnf$2$subexpression$1", "symbols": ["comma", "expr_list_raw"], "postprocess": last},
    {"name": "raise_statement$ebnf$2", "symbols": ["raise_statement$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "raise_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "raise_statement$ebnf$3", "symbols": ["raise_using"], "postprocess": id},
    {"name": "raise_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "raise_statement", "symbols": ["kw_raise", "raise_statement$ebnf$1", "string", "raise_statement$ebnf$2", "raise_statement$ebnf$3"], "postprocess":  x => track(x, {
            type: 'raise',
            format: toStr(x[2]),
            ...x[1] && { level: toStr(x[1]) },
            ...x[3] && x[3].length && { formatExprs: x[3] },
            ...x[4] && x[4].length && { using: x[4] },
        }) },
    {"name": "raise_using$macrocall$2", "symbols": ["raise_using_one"]},
    {"name": "raise_using$macrocall$1$ebnf$1", "symbols": []},
    {"name": "raise_using$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "raise_using$macrocall$2"], "postprocess": last},
    {"name": "raise_using$macrocall$1$ebnf$1", "symbols": ["raise_using$macrocall$1$ebnf$1", "raise_using$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "raise_using$macrocall$1", "symbols": ["raise_using$macrocall$2", "raise_using$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "raise_using", "symbols": [(lexerAny.has("kw_using") ? {type: "kw_using"} : kw_using), "raise_using$macrocall$1"], "postprocess": last},
    {"name": "raise_using_one", "symbols": ["raise_using_what", (lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq), "expr"], "postprocess":  x => track(x, {
            type: toStr(x[0]),
            value: x[2],
        }) },
    {"name": "raise_using_what", "symbols": [(lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table)]},
    {"name": "raise_using_what", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess":  anyKw('message',
        'detail',
        'hint',
        'errcode',
        'column',
        'constraint',
        'datatype',
        'schema') },
    {"name": "comment_statement", "symbols": ["kw_comment", (lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "comment_what", (lexerAny.has("kw_is") ? {type: "kw_is"} : kw_is), "string"], "postprocess":  x => track(x, {
            type: 'comment',
            comment: unbox(last(x)),
            on: unwrap(x[2]),
        }) },
    {"name": "comment_what", "symbols": ["comment_what_col"]},
    {"name": "comment_what", "symbols": ["comment_what_nm"]},
    {"name": "comment_what_nm$subexpression$1", "symbols": [(lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table)]},
    {"name": "comment_what_nm$subexpression$1", "symbols": ["kw_materialized", "kw_view"]},
    {"name": "comment_what_nm$subexpression$1", "symbols": [(lexerAny.has("word") ? {type: "word"} : word)], "postprocess": anyKw('database', 'index', 'trigger', 'type', 'view')},
    {"name": "comment_what_nm", "symbols": ["comment_what_nm$subexpression$1", "qualified_name"], "postprocess":  x => track(x, {
            type: toStr(x[0]),
            name: x[1],
        }) },
    {"name": "comment_what_col", "symbols": ["kw_column", "qcolumn"], "postprocess":  x => track(x, {
            type: 'column',
            column: last(x),
        }) },
    {"name": "simplestatements_begin$ebnf$1$subexpression$1", "symbols": ["kw_transaction"]},
    {"name": "simplestatements_begin$ebnf$1$subexpression$1", "symbols": ["kw_work"]},
    {"name": "simplestatements_begin$ebnf$1", "symbols": ["simplestatements_begin$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "simplestatements_begin$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "simplestatements_begin$ebnf$2", "symbols": []},
    {"name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_isol"]},
    {"name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_writ"]},
    {"name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_def"]},
    {"name": "simplestatements_begin$ebnf$2", "symbols": ["simplestatements_begin$ebnf$2", "simplestatements_begin$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "simplestatements_begin", "symbols": ["kw_begin", "simplestatements_begin$ebnf$1", "simplestatements_begin$ebnf$2"], "postprocess": 
        x => track(x, {
            type: 'begin',
            ...x[2].reduce((a: any, b: any) => ({...unwrap(a), ...unwrap(b)}), {}),
        })
        },
    {"name": "simplestatements_begin_isol$subexpression$1", "symbols": ["kw_isolation", "kw_level"]},
    {"name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_serializable"]},
    {"name": "simplestatements_begin_isol$subexpression$2$subexpression$1", "symbols": ["word"], "postprocess": kw('repeatable')},
    {"name": "simplestatements_begin_isol$subexpression$2", "symbols": ["simplestatements_begin_isol$subexpression$2$subexpression$1", "kw_read"]},
    {"name": "simplestatements_begin_isol$subexpression$2$subexpression$2", "symbols": ["word"], "postprocess": kw('committed')},
    {"name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_read", "simplestatements_begin_isol$subexpression$2$subexpression$2"]},
    {"name": "simplestatements_begin_isol$subexpression$2$subexpression$3", "symbols": ["word"], "postprocess": kw('uncommitted')},
    {"name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_read", "simplestatements_begin_isol$subexpression$2$subexpression$3"]},
    {"name": "simplestatements_begin_isol", "symbols": ["simplestatements_begin_isol$subexpression$1", "simplestatements_begin_isol$subexpression$2"], "postprocess":  x => track(x, {
            isolationLevel: toStr(x[1], ' '),
        }) },
    {"name": "simplestatements_begin_writ$subexpression$1", "symbols": ["kw_read", "kw_write"]},
    {"name": "simplestatements_begin_writ$subexpression$1", "symbols": ["kw_read", (lexerAny.has("kw_only") ? {type: "kw_only"} : kw_only)]},
    {"name": "simplestatements_begin_writ", "symbols": ["simplestatements_begin_writ$subexpression$1"], "postprocess":  x => track(x, {
            writeable: toStr(x, ' '),
        }) },
    {"name": "simplestatements_begin_def$ebnf$1", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)], "postprocess": id},
    {"name": "simplestatements_begin_def$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "simplestatements_begin_def", "symbols": ["simplestatements_begin_def$ebnf$1", (lexerAny.has("kw_deferrable") ? {type: "kw_deferrable"} : kw_deferrable)], "postprocess":  x => track(x, {
            deferrable: !x[0]
        }) },
    {"name": "insert_statement$subexpression$1", "symbols": ["kw_insert", (lexerAny.has("kw_into") ? {type: "kw_into"} : kw_into)]},
    {"name": "insert_statement$ebnf$1", "symbols": ["collist_paren"], "postprocess": id},
    {"name": "insert_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "insert_statement$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_system"]},
    {"name": "insert_statement$ebnf$2$subexpression$1$subexpression$1", "symbols": [(lexerAny.has("kw_user") ? {type: "kw_user"} : kw_user)]},
    {"name": "insert_statement$ebnf$2$subexpression$1", "symbols": ["kw_overriding", "insert_statement$ebnf$2$subexpression$1$subexpression$1", "kw_value"], "postprocess": get(1)},
    {"name": "insert_statement$ebnf$2", "symbols": ["insert_statement$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "insert_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "insert_statement$ebnf$3$subexpression$1", "symbols": ["selection"]},
    {"name": "insert_statement$ebnf$3$subexpression$1", "symbols": ["selection_paren"]},
    {"name": "insert_statement$ebnf$3", "symbols": ["insert_statement$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "insert_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "insert_statement$ebnf$4$subexpression$1", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), "kw_conflict", "insert_on_conflict"], "postprocess": last},
    {"name": "insert_statement$ebnf$4", "symbols": ["insert_statement$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "insert_statement$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "insert_statement$ebnf$5$subexpression$1", "symbols": [(lexerAny.has("kw_returning") ? {type: "kw_returning"} : kw_returning), "select_expr_list_aliased"], "postprocess": last},
    {"name": "insert_statement$ebnf$5", "symbols": ["insert_statement$ebnf$5$subexpression$1"], "postprocess": id},
    {"name": "insert_statement$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "insert_statement", "symbols": ["insert_statement$subexpression$1", "table_ref_aliased", "insert_statement$ebnf$1", "insert_statement$ebnf$2", "insert_statement$ebnf$3", "insert_statement$ebnf$4", "insert_statement$ebnf$5"], "postprocess":  x => {
            const columns = x[2] && x[2].map(asName);
            const overriding = toStr(x[3]);
            const insert = unwrap(x[4]);
            const onConflict = x[5];
            const returning = x[6];
            return track(x, {
                type: 'insert',
                into: unwrap(x[1]),
                insert,
                ...overriding && { overriding },
                ...columns && { columns },
                ...returning && { returning },
                ...onConflict && { onConflict },
            })
        } },
    {"name": "insert_values$ebnf$1", "symbols": []},
    {"name": "insert_values$ebnf$1$subexpression$1", "symbols": ["comma", "insert_value"], "postprocess": last},
    {"name": "insert_values$ebnf$1", "symbols": ["insert_values$ebnf$1", "insert_values$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "insert_values", "symbols": ["insert_value", "insert_values$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "insert_value", "symbols": ["lparen", "insert_expr_list_raw", "rparen"], "postprocess": get(1)},
    {"name": "insert_expr_list_raw$ebnf$1", "symbols": []},
    {"name": "insert_expr_list_raw$ebnf$1$subexpression$1", "symbols": ["comma", "expr_or_select"], "postprocess": last},
    {"name": "insert_expr_list_raw$ebnf$1", "symbols": ["insert_expr_list_raw$ebnf$1", "insert_expr_list_raw$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "insert_expr_list_raw", "symbols": ["expr_or_select", "insert_expr_list_raw$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "insert_on_conflict$ebnf$1", "symbols": ["insert_on_conflict_what"], "postprocess": id},
    {"name": "insert_on_conflict$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "insert_on_conflict", "symbols": ["insert_on_conflict$ebnf$1", "insert_on_conflict_do"], "postprocess":  x => track(x, {
            ...x[0] ? { on: unwrap(x[0]) } : {},
            ...x[1],
        }) },
    {"name": "insert_on_conflict_what", "symbols": ["lparen", "expr_list_raw", "rparen"], "postprocess":  x => track(x, {
            type: 'on expr',
            exprs: x[1],
        }) },
    {"name": "insert_on_conflict_what", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), (lexerAny.has("kw_constraint") ? {type: "kw_constraint"} : kw_constraint), "qname"], "postprocess":  x => track(x, {
            type: 'on constraint',
            constraint: last(x),
        }) },
    {"name": "insert_on_conflict_do", "symbols": [(lexerAny.has("kw_do") ? {type: "kw_do"} : kw_do), "kw_nothing"], "postprocess": x => ({ do: 'do nothing' })},
    {"name": "insert_on_conflict_do$subexpression$1", "symbols": [(lexerAny.has("kw_do") ? {type: "kw_do"} : kw_do), "kw_update", "kw_set"]},
    {"name": "insert_on_conflict_do$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_where") ? {type: "kw_where"} : kw_where), "expr"], "postprocess": last},
    {"name": "insert_on_conflict_do$ebnf$1", "symbols": ["insert_on_conflict_do$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "insert_on_conflict_do$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "insert_on_conflict_do", "symbols": ["insert_on_conflict_do$subexpression$1", "update_set_list", "insert_on_conflict_do$ebnf$1"], "postprocess":  x => ({
           do: { sets: x[1] },
           ...x[2] && { where: x[2] },
        }) },
    {"name": "update_statement$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from), "select_from_subject"], "postprocess": last},
    {"name": "update_statement$ebnf$1", "symbols": ["update_statement$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "update_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "update_statement$ebnf$2", "symbols": ["select_where"], "postprocess": id},
    {"name": "update_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "update_statement$ebnf$3$subexpression$1", "symbols": [(lexerAny.has("kw_returning") ? {type: "kw_returning"} : kw_returning), "select_expr_list_aliased"], "postprocess": last},
    {"name": "update_statement$ebnf$3", "symbols": ["update_statement$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "update_statement$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "update_statement", "symbols": ["kw_update", "table_ref_aliased", "kw_set", "update_set_list", "update_statement$ebnf$1", "update_statement$ebnf$2", "update_statement$ebnf$3"], "postprocess":  x => {
            const from = unwrap(x[4]);
            const where = unwrap(x[5]);
            const returning = x[6];
            return track(x, {
                type: 'update',
                table: unwrap(x[1]),
                sets: x[3],
                ...where ? {where} : {},
                ...from ? {from} : {},
                ...returning ? {returning} : {},
            });
        } },
    {"name": "update_set_list$ebnf$1", "symbols": []},
    {"name": "update_set_list$ebnf$1$subexpression$1", "symbols": ["comma", "update_set"], "postprocess": last},
    {"name": "update_set_list$ebnf$1", "symbols": ["update_set_list$ebnf$1", "update_set_list$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "update_set_list", "symbols": ["update_set", "update_set_list$ebnf$1"], "postprocess":  ([head, tail]) => {
            const ret = [];
            for (const _t of [head, ...(tail || [])]) {
                const t = unwrap(_t);
                if (Array.isArray(t)) {
                    ret.push(...t);
                } else {
                    ret.push(t);
                }
            }
            return ret;
        } },
    {"name": "update_set", "symbols": ["update_set_one"]},
    {"name": "update_set", "symbols": ["update_set_multiple"]},
    {"name": "update_set_one", "symbols": ["ident", (lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq), "expr"], "postprocess":  x => box(x, {
            column: asName(x[0]),
            value: unwrap(x[2]),
        }) },
    {"name": "update_set_multiple$subexpression$1", "symbols": ["lparen", "expr_list_raw", "rparen"], "postprocess": get(1)},
    {"name": "update_set_multiple", "symbols": ["collist_paren", (lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq), "update_set_multiple$subexpression$1"], "postprocess":  x => {
            const cols = x[0];
            const exprs = x[2];
            if (cols.length !== exprs.length) {
                throw new Error('number of columns does not match number of values');
            }
            return box(x, cols.map((x: any, i: number) => ({
                column: asName(x),
                value: unwrap(exprs[i]),
            })))
        } },
    {"name": "altertable_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id},
    {"name": "altertable_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altertable_statement$ebnf$2", "symbols": [(lexerAny.has("kw_only") ? {type: "kw_only"} : kw_only)], "postprocess": id},
    {"name": "altertable_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "altertable_statement", "symbols": ["kw_alter", (lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table), "altertable_statement$ebnf$1", "altertable_statement$ebnf$2", "table_ref", "altertable_actions"], "postprocess":  x => track(x, {
            type: 'alter table',
            ... x[2] ? {ifExists: true} : {},
            ... x[3] ? {only: true} : {},
            table: unwrap(x[4]),
            changes: unbox(x[5]).map(unwrap),
        }) },
    {"name": "altertable_actions$ebnf$1", "symbols": []},
    {"name": "altertable_actions$ebnf$1$subexpression$1", "symbols": ["comma", "altertable_action"], "postprocess": last},
    {"name": "altertable_actions$ebnf$1", "symbols": ["altertable_actions$ebnf$1", "altertable_actions$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "altertable_actions", "symbols": ["altertable_action", "altertable_actions$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "altertable_action", "symbols": ["altertable_rename_table"]},
    {"name": "altertable_action", "symbols": ["altertable_rename_column"]},
    {"name": "altertable_action", "symbols": ["altertable_rename_constraint"]},
    {"name": "altertable_action", "symbols": ["altertable_add_column"]},
    {"name": "altertable_action", "symbols": ["altertable_drop_column"]},
    {"name": "altertable_action", "symbols": ["altertable_alter_column"]},
    {"name": "altertable_action", "symbols": ["altertable_add_constraint"]},
    {"name": "altertable_action", "symbols": ["altertable_drop_constraint"]},
    {"name": "altertable_action", "symbols": ["altertable_owner"]},
    {"name": "altertable_rename_table", "symbols": ["kw_rename", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "word"], "postprocess":  x => track(x, {
            type: 'rename',
            to: asName(last(x)),
        }) },
    {"name": "altertable_rename_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id},
    {"name": "altertable_rename_column$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altertable_rename_column", "symbols": ["kw_rename", "altertable_rename_column$ebnf$1", "ident", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "ident"], "postprocess":  x => track(x, {
            type: 'rename column',
            column: asName(x[2]),
            to: asName(last(x)),
        }) },
    {"name": "altertable_rename_constraint", "symbols": ["kw_rename", (lexerAny.has("kw_constraint") ? {type: "kw_constraint"} : kw_constraint), "ident", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "ident"], "postprocess":  x => track(x, {
            type: 'rename constraint',
            constraint: asName(x[2]),
            to: asName(last(x)),
        }) },
    {"name": "altertable_add_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id},
    {"name": "altertable_add_column$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altertable_add_column$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "altertable_add_column$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "altertable_add_column", "symbols": ["kw_add", "altertable_add_column$ebnf$1", "altertable_add_column$ebnf$2", "createtable_column"], "postprocess":  x => track(x, {
            type: 'add column',
            ... x[2] ? {ifNotExists: true} : {},
            column: unwrap(x[3]),
        }) },
    {"name": "altertable_drop_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id},
    {"name": "altertable_drop_column$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altertable_drop_column$ebnf$2", "symbols": ["kw_ifexists"], "postprocess": id},
    {"name": "altertable_drop_column$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "altertable_drop_column$ebnf$3$subexpression$1", "symbols": ["kw_restrict"]},
    {"name": "altertable_drop_column$ebnf$3$subexpression$1", "symbols": ["kw_cascade"]},
    {"name": "altertable_drop_column$ebnf$3", "symbols": ["altertable_drop_column$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "altertable_drop_column$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "altertable_drop_column", "symbols": ["kw_drop", "altertable_drop_column$ebnf$1", "altertable_drop_column$ebnf$2", "ident", "altertable_drop_column$ebnf$3"], "postprocess":  x => track(x, {
            type: 'drop column',
            ... x[2] ? {ifExists: true} : {},
            column: asName(x[3]),
            ... x[4] ? {behaviour: toStr(x[4], ' ')} : {},
        }) },
    {"name": "altertable_alter_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id},
    {"name": "altertable_alter_column$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altertable_alter_column", "symbols": ["kw_alter", "altertable_alter_column$ebnf$1", "ident", "altercol"], "postprocess":  x => track(x, {
            type: 'alter column',
            column: asName(x[2]),
            alter: unwrap(x[3])
        }) },
    {"name": "altercol$ebnf$1$subexpression$1", "symbols": ["kw_set", "kw_data"]},
    {"name": "altercol$ebnf$1", "symbols": ["altercol$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "altercol$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altercol", "symbols": ["altercol$ebnf$1", "kw_type", "data_type"], "postprocess": x => track(x, { type: 'set type', dataType: unwrap(last(x)) })},
    {"name": "altercol", "symbols": ["kw_set", (lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default), "expr"], "postprocess": x => track(x, {type: 'set default', default: unwrap(last(x)) })},
    {"name": "altercol", "symbols": ["kw_drop", (lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)], "postprocess": x => track(x, {type: 'drop default' })},
    {"name": "altercol$subexpression$1", "symbols": ["kw_set"]},
    {"name": "altercol$subexpression$1", "symbols": ["kw_drop"]},
    {"name": "altercol", "symbols": ["altercol$subexpression$1", "kw_not_null"], "postprocess": x => track(x, {type: toStr(x, ' ') })},
    {"name": "altercol", "symbols": ["altercol_generated_add"], "postprocess": unwrap},
    {"name": "altertable_add_constraint", "symbols": ["kw_add", "createtable_constraint"], "postprocess":  x => track(x, {
            type: 'add constraint',
            constraint: unwrap(last(x)),
        }) },
    {"name": "altertable_drop_constraint$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id},
    {"name": "altertable_drop_constraint$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altertable_drop_constraint$ebnf$2$subexpression$1", "symbols": ["kw_restrict"]},
    {"name": "altertable_drop_constraint$ebnf$2$subexpression$1", "symbols": ["kw_cascade"]},
    {"name": "altertable_drop_constraint$ebnf$2", "symbols": ["altertable_drop_constraint$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "altertable_drop_constraint$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "altertable_drop_constraint", "symbols": ["kw_drop", (lexerAny.has("kw_constraint") ? {type: "kw_constraint"} : kw_constraint), "altertable_drop_constraint$ebnf$1", "ident", "altertable_drop_constraint$ebnf$2"], "postprocess":  x => track(x, {
            type: 'drop constraint',
            ... x[2] ? {ifExists: true} : {},
            constraint: asName(x[3]),
            ... x[4] ? {behaviour: toStr(x[4], ' ')} : {},
        }) },
    {"name": "altertable_owner", "symbols": ["kw_owner", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "ident"], "postprocess":  x => track(x, {
            type:'owner',
            to: asName(last(x)),
        }) },
    {"name": "altercol_generated_add", "symbols": ["kw_add", "altercol_generated"], "postprocess": last},
    {"name": "altercol_generated$ebnf$1$subexpression$1", "symbols": ["kw_always"]},
    {"name": "altercol_generated$ebnf$1$subexpression$1", "symbols": ["kw_by", (lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default)]},
    {"name": "altercol_generated$ebnf$1", "symbols": ["altercol_generated$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "altercol_generated$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altercol_generated$subexpression$1", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "kw_identity"]},
    {"name": "altercol_generated$ebnf$2$subexpression$1", "symbols": ["lparen", "altercol_generated_seq", "rparen"], "postprocess": get(1)},
    {"name": "altercol_generated$ebnf$2", "symbols": ["altercol_generated$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "altercol_generated$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "altercol_generated", "symbols": ["kw_generated", "altercol_generated$ebnf$1", "altercol_generated$subexpression$1", "altercol_generated$ebnf$2"], "postprocess":  x => track(x, {
            type: 'add generated',
            ...x[1] && { always: toStr(x[1], ' ') },
            ...x[3] && { sequence: unwrap(x[3]) },
        }) },
    {"name": "altercol_generated_seq$ebnf$1$subexpression$1", "symbols": ["kw_sequence", "kw_name", "qualified_name"]},
    {"name": "altercol_generated_seq$ebnf$1", "symbols": ["altercol_generated_seq$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "altercol_generated_seq$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "altercol_generated_seq$ebnf$2", "symbols": []},
    {"name": "altercol_generated_seq$ebnf$2", "symbols": ["altercol_generated_seq$ebnf$2", "create_sequence_option"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "altercol_generated_seq", "symbols": ["altercol_generated_seq$ebnf$1", "altercol_generated_seq$ebnf$2"], "postprocess":  x => {
            const ret: any = {
                ...x[0] && { name: unwrap(last(x[0])) },
            };
            setSeqOpts(ret, x[1]);
            return track(x, ret);
        }},
    {"name": "alterindex_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id},
    {"name": "alterindex_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "alterindex_statement", "symbols": ["kw_alter", "kw_index", "alterindex_statement$ebnf$1", "table_ref", "alterindex_action"], "postprocess":  x => track(x, {
            type: 'alter index',
            ... x[2] ? {ifExists: true} : {},
            index: unwrap(x[3]),
            change: unwrap(x[4]),
        }) },
    {"name": "alterindex_action", "symbols": ["alterindex_rename"]},
    {"name": "alterindex_action", "symbols": ["alterindex_set_tablespace"]},
    {"name": "alterindex_rename", "symbols": ["kw_rename", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "word"], "postprocess":  x => track(x, {
            type: 'rename',
            to: asName(last(x)),
        }) },
    {"name": "alterindex_set_tablespace", "symbols": ["kw_set", "kw_tablespace", "word"], "postprocess":  x => track(x, {
            type: 'set tablespace',
            tablespace: asName(last(x)),
        }) },
    {"name": "delete_statement", "symbols": ["delete_delete"]},
    {"name": "delete_statement", "symbols": ["delete_truncate"]},
    {"name": "delete_delete$subexpression$1", "symbols": ["kw_delete", (lexerAny.has("kw_from") ? {type: "kw_from"} : kw_from)]},
    {"name": "delete_delete$ebnf$1", "symbols": ["select_where"], "postprocess": id},
    {"name": "delete_delete$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "delete_delete$ebnf$2$subexpression$1", "symbols": [(lexerAny.has("kw_returning") ? {type: "kw_returning"} : kw_returning), "select_expr_list_aliased"], "postprocess": last},
    {"name": "delete_delete$ebnf$2", "symbols": ["delete_delete$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "delete_delete$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "delete_delete", "symbols": ["delete_delete$subexpression$1", "table_ref_aliased", "delete_delete$ebnf$1", "delete_delete$ebnf$2"], "postprocess":  x => {
            const where = x[2];
            const returning = x[3];
            return track(x, {
                type: 'delete',
                from: unwrap(x[1]),
                ...where ? { where } : {},
                ...returning ? { returning } : {},
            });
        } },
    {"name": "delete_truncate$subexpression$1$ebnf$1", "symbols": [(lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table)], "postprocess": id},
    {"name": "delete_truncate$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "delete_truncate$subexpression$1", "symbols": ["kw_truncate", "delete_truncate$subexpression$1$ebnf$1"]},
    {"name": "delete_truncate$macrocall$2", "symbols": ["table_ref"]},
    {"name": "delete_truncate$macrocall$1$ebnf$1", "symbols": []},
    {"name": "delete_truncate$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "delete_truncate$macrocall$2"], "postprocess": last},
    {"name": "delete_truncate$macrocall$1$ebnf$1", "symbols": ["delete_truncate$macrocall$1$ebnf$1", "delete_truncate$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "delete_truncate$macrocall$1", "symbols": ["delete_truncate$macrocall$2", "delete_truncate$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1", "symbols": ["kw_restart"]},
    {"name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1", "symbols": ["kw_continue"]},
    {"name": "delete_truncate$ebnf$1$subexpression$1", "symbols": ["delete_truncate$ebnf$1$subexpression$1$subexpression$1", "kw_identity"]},
    {"name": "delete_truncate$ebnf$1", "symbols": ["delete_truncate$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "delete_truncate$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "delete_truncate$ebnf$2$subexpression$1", "symbols": ["kw_restrict"]},
    {"name": "delete_truncate$ebnf$2$subexpression$1", "symbols": ["kw_cascade"]},
    {"name": "delete_truncate$ebnf$2", "symbols": ["delete_truncate$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "delete_truncate$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "delete_truncate", "symbols": ["delete_truncate$subexpression$1", "delete_truncate$macrocall$1", "delete_truncate$ebnf$1", "delete_truncate$ebnf$2"], "postprocess":  x => track(x, {
            type: 'truncate table',
            tables: x[1],
            ...x[2] && { identity: toStr(x[2][0]) },
            ... x[3] && {cascade: toStr(x[3]) },
        }) },
    {"name": "create_sequence_statement$ebnf$1$subexpression$1", "symbols": ["kw_temp"]},
    {"name": "create_sequence_statement$ebnf$1$subexpression$1", "symbols": ["kw_temporary"]},
    {"name": "create_sequence_statement$ebnf$1", "symbols": ["create_sequence_statement$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "create_sequence_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_sequence_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "create_sequence_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "create_sequence_statement$ebnf$3", "symbols": []},
    {"name": "create_sequence_statement$ebnf$3", "symbols": ["create_sequence_statement$ebnf$3", "create_sequence_option"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "create_sequence_statement", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "create_sequence_statement$ebnf$1", "kw_sequence", "create_sequence_statement$ebnf$2", "qualified_name", "create_sequence_statement$ebnf$3"], "postprocess":  x => {
            const ret: any = {
                type: 'create sequence',
                ...x[1] && { temp: true },
                ...x[3] && { ifNotExists: true },
                name: unwrap(x[4]),
                options: {},
            };
            setSeqOpts(ret.options, x[5]);
            return track(x, ret);
        }},
    {"name": "create_sequence_option", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "data_type"], "postprocess": x => box(x, ['as', x[1]])},
    {"name": "create_sequence_option$ebnf$1", "symbols": ["kw_by"], "postprocess": id},
    {"name": "create_sequence_option$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_sequence_option", "symbols": ["kw_increment", "create_sequence_option$ebnf$1", "int"], "postprocess": x => box(x, ['incrementBy', x[2]])},
    {"name": "create_sequence_option", "symbols": ["create_sequence_minvalue"], "postprocess": x => box(x, ['minValue', x[0]])},
    {"name": "create_sequence_option", "symbols": ["create_sequence_maxvalue"], "postprocess": x => box(x, ['maxValue', x[0]])},
    {"name": "create_sequence_option$ebnf$2", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with)], "postprocess": id},
    {"name": "create_sequence_option$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "create_sequence_option", "symbols": ["kw_start", "create_sequence_option$ebnf$2", "int"], "postprocess": x => box(x, ['startWith', x[2]])},
    {"name": "create_sequence_option", "symbols": ["kw_cache", "int"], "postprocess": x => box(x, ['cache', x[1]])},
    {"name": "create_sequence_option$ebnf$3", "symbols": ["kw_no"], "postprocess": id},
    {"name": "create_sequence_option$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "create_sequence_option", "symbols": ["create_sequence_option$ebnf$3", "kw_cycle"], "postprocess": x => box(x, ['cycle', toStr(x, ' ')])},
    {"name": "create_sequence_option", "symbols": ["create_sequence_owned_by"], "postprocess": x => box(x, ['ownedBy', unwrap(x)])},
    {"name": "create_sequence_minvalue", "symbols": ["kw_minvalue", "int"], "postprocess": last},
    {"name": "create_sequence_minvalue", "symbols": ["kw_no", "kw_minvalue"], "postprocess": x => box(x, 'no minvalue')},
    {"name": "create_sequence_maxvalue", "symbols": ["kw_maxvalue", "int"], "postprocess": last},
    {"name": "create_sequence_maxvalue", "symbols": ["kw_no", "kw_maxvalue"], "postprocess": x => box(x, 'no maxvalue')},
    {"name": "create_sequence_owned_by$subexpression$1", "symbols": ["kw_none"]},
    {"name": "create_sequence_owned_by$subexpression$1", "symbols": ["qcolumn"]},
    {"name": "create_sequence_owned_by", "symbols": ["kw_owned", "kw_by", "create_sequence_owned_by$subexpression$1"], "postprocess": x => box(x, unwrap(last(x)))},
    {"name": "alter_sequence_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id},
    {"name": "alter_sequence_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "alter_sequence_statement", "symbols": ["kw_alter", "kw_sequence", "alter_sequence_statement$ebnf$1", "qualified_name", "alter_sequence_statement_body"], "postprocess":  x => {
            const ret: any = {
                type: 'alter sequence',
                ...x[2] && { ifExists: true },
                name: unwrap(x[3]),
                change: x[4],
            };
            return track(x, ret);
        }},
    {"name": "alter_sequence_statement_body$ebnf$1", "symbols": ["alter_sequence_option"]},
    {"name": "alter_sequence_statement_body$ebnf$1", "symbols": ["alter_sequence_statement_body$ebnf$1", "alter_sequence_option"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "alter_sequence_statement_body", "symbols": ["alter_sequence_statement_body$ebnf$1"], "postprocess":  x => {
            const ret: any = {
                type: 'set options',
            };
            setSeqOpts(ret, x[0]);
            return track(x, ret);
        }},
    {"name": "alter_sequence_statement_body$subexpression$1", "symbols": ["ident"]},
    {"name": "alter_sequence_statement_body$subexpression$1", "symbols": [(lexerAny.has("kw_session_user") ? {type: "kw_session_user"} : kw_session_user)]},
    {"name": "alter_sequence_statement_body$subexpression$1", "symbols": [(lexerAny.has("kw_current_user") ? {type: "kw_current_user"} : kw_current_user)]},
    {"name": "alter_sequence_statement_body", "symbols": ["kw_owner", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "alter_sequence_statement_body$subexpression$1"], "postprocess": x => track(x, { type: 'owner to', owner: asName(last(x)), })},
    {"name": "alter_sequence_statement_body", "symbols": ["kw_rename", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "ident"], "postprocess": x => track(x, { type: 'rename', newName: asName(last(x)) })},
    {"name": "alter_sequence_statement_body", "symbols": ["kw_set", "kw_schema", "ident"], "postprocess": x => track(x, { type: 'set schema', newSchema: asName(last(x)) })},
    {"name": "alter_sequence_option", "symbols": ["create_sequence_option"], "postprocess": unwrap},
    {"name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with)], "postprocess": id},
    {"name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "alter_sequence_option$ebnf$1$subexpression$1", "symbols": ["alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "int"], "postprocess": last},
    {"name": "alter_sequence_option$ebnf$1", "symbols": ["alter_sequence_option$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "alter_sequence_option$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "alter_sequence_option", "symbols": ["kw_restart", "alter_sequence_option$ebnf$1"], "postprocess": x => box(x, ['restart', typeof unbox(x[1]) === 'number' ? unbox(x[1]) : true])},
    {"name": "drop_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id},
    {"name": "drop_statement$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "drop_statement$macrocall$2", "symbols": ["qualified_name"]},
    {"name": "drop_statement$macrocall$1$ebnf$1", "symbols": []},
    {"name": "drop_statement$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "drop_statement$macrocall$2"], "postprocess": last},
    {"name": "drop_statement$macrocall$1$ebnf$1", "symbols": ["drop_statement$macrocall$1$ebnf$1", "drop_statement$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "drop_statement$macrocall$1", "symbols": ["drop_statement$macrocall$2", "drop_statement$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "drop_statement$ebnf$2$subexpression$1", "symbols": ["kw_cascade"]},
    {"name": "drop_statement$ebnf$2$subexpression$1", "symbols": ["kw_restrict"]},
    {"name": "drop_statement$ebnf$2", "symbols": ["drop_statement$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "drop_statement$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "drop_statement", "symbols": ["kw_drop", "drop_what", "drop_statement$ebnf$1", "drop_statement$macrocall$1", "drop_statement$ebnf$2"], "postprocess":  (x: any, rej: any) => {
            const v = unwrap(x[1]);
            return track(x, {
                ...v,
                ... x[2] && {ifExists: true},
                names: x[3],
                ... x[4] && {cascade: toStr(x[4]) },
            });
        }},
    {"name": "drop_what", "symbols": [(lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table)], "postprocess": x => track(x, { type: 'drop table' })},
    {"name": "drop_what", "symbols": ["kw_sequence"], "postprocess": x => track(x, { type: 'drop sequence' })},
    {"name": "drop_what", "symbols": ["kw_type"], "postprocess": x => track(x, { type: 'drop type' })},
    {"name": "drop_what", "symbols": ["kw_trigger"], "postprocess": x => track(x, { type: 'drop trigger' })},
    {"name": "drop_what$ebnf$1", "symbols": [(lexerAny.has("kw_concurrently") ? {type: "kw_concurrently"} : kw_concurrently)], "postprocess": id},
    {"name": "drop_what$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "drop_what", "symbols": ["kw_index", "drop_what$ebnf$1"], "postprocess":  x => track(x, {
            type: 'drop index',
            ...x[1] && {concurrently: true },
        }) },
    {"name": "with_statement", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "with_statement_bindings", "with_statement_statement"], "postprocess":  x => track(x, {
            type: 'with',
            bind: x[1],
            in: unwrap(x[2]),
        }) },
    {"name": "with_recursive_statement$subexpression$1", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "kw_recursive"]},
    {"name": "with_recursive_statement", "symbols": ["with_recursive_statement$subexpression$1", "ident", "collist_paren", (lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "lparen", "union_statement", "rparen", "with_statement_statement"], "postprocess":  x => track(x, {
            type: 'with recursive',
            alias: asName(x[1]),
            columnNames: x[2].map(asName),
            bind: x[5],
            in: unwrap(x[7]),
        }) },
    {"name": "with_statement_bindings$ebnf$1", "symbols": []},
    {"name": "with_statement_bindings$ebnf$1$subexpression$1", "symbols": ["comma", "with_statement_binding"], "postprocess": last},
    {"name": "with_statement_bindings$ebnf$1", "symbols": ["with_statement_bindings$ebnf$1", "with_statement_bindings$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "with_statement_bindings", "symbols": ["with_statement_binding", "with_statement_bindings$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [head, ...(tail || [])];
        } },
    {"name": "with_statement_binding", "symbols": ["word", (lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "lparen", "with_statement_statement", "rparen"], "postprocess":  x => track(x, {
            alias: asName(x[0]),
            statement: unwrap(x[3]),
        }) },
    {"name": "with_statement_statement", "symbols": ["selection"]},
    {"name": "with_statement_statement", "symbols": ["insert_statement"]},
    {"name": "with_statement_statement", "symbols": ["update_statement"]},
    {"name": "with_statement_statement", "symbols": ["delete_statement"]},
    {"name": "createtype_statement$subexpression$1", "symbols": ["createtype_enum"]},
    {"name": "createtype_statement$subexpression$1", "symbols": ["createtype_composite"]},
    {"name": "createtype_statement", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "kw_type", "qualified_name", "createtype_statement$subexpression$1"], "postprocess":  x => track(x, {
            name: x[2],
            ...unwrap(x[3]),
        }) },
    {"name": "createtype_enum$macrocall$2", "symbols": ["enum_value"]},
    {"name": "createtype_enum$macrocall$1$ebnf$1", "symbols": []},
    {"name": "createtype_enum$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "createtype_enum$macrocall$2"], "postprocess": last},
    {"name": "createtype_enum$macrocall$1$ebnf$1", "symbols": ["createtype_enum$macrocall$1$ebnf$1", "createtype_enum$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtype_enum$macrocall$1", "symbols": ["createtype_enum$macrocall$2", "createtype_enum$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "createtype_enum", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "kw_enum", "lparen", "createtype_enum$macrocall$1", "rparen"], "postprocess":  x => track(x, {
            type: 'create enum',
            values: x[3],
        }) },
    {"name": "enum_value", "symbols": ["string"], "postprocess": x => track(x, {value: toStr(x) })},
    {"name": "createtype_composite$macrocall$2", "symbols": ["createtype_composite_attr"]},
    {"name": "createtype_composite$macrocall$1$ebnf$1", "symbols": []},
    {"name": "createtype_composite$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "createtype_composite$macrocall$2"], "postprocess": last},
    {"name": "createtype_composite$macrocall$1$ebnf$1", "symbols": ["createtype_composite$macrocall$1$ebnf$1", "createtype_composite$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "createtype_composite$macrocall$1", "symbols": ["createtype_composite$macrocall$2", "createtype_composite$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "createtype_composite", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "lparen", "createtype_composite$macrocall$1", "rparen"], "postprocess":  x => track(x, {
            type: 'create composite type',
            attributes: x[2],
        }) },
    {"name": "createtype_composite_attr$ebnf$1", "symbols": ["createtable_collate"], "postprocess": id},
    {"name": "createtype_composite_attr$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "createtype_composite_attr", "symbols": ["word", "data_type", "createtype_composite_attr$ebnf$1"], "postprocess":  x => {
            return track(x, {
                name: asName(x[0]),
                dataType: x[1],
                ...x[2] ? { collate: x[2][1] }: {},
            })
        } },
    {"name": "altertype_statement$subexpression$1", "symbols": ["altertype_enum_add_value"]},
    {"name": "altertype_statement$subexpression$1", "symbols": ["altertype_enum_rename"]},
    {"name": "altertype_statement", "symbols": ["kw_alter", "kw_type", "qualified_name", "altertype_statement$subexpression$1"], "postprocess":  x => track(x, {
            name: x[2],
            ...unwrap(x[3]),
        }) },
    {"name": "altertype_enum_add_value", "symbols": ["kw_add", "kw_value", "enum_additional_value"], "postprocess":  x => track(x, {
            type: 'alter enum',
            change: {
              type: 'add value',
              add: x[2]
            }
        }) },
    {"name": "enum_additional_value", "symbols": ["string"], "postprocess": x => track(x, {value: toStr(x) })},
    {"name": "altertype_enum_rename", "symbols": ["kw_rename", (lexerAny.has("kw_to") ? {type: "kw_to"} : kw_to), "word"], "postprocess":  x => track(x, {
            type: 'alter enum',
            change: {
              type: 'rename',
              to: asName(last(x))
            }
        }) },
    {"name": "union_left", "symbols": ["select_statement"]},
    {"name": "union_left", "symbols": ["select_values"]},
    {"name": "union_left", "symbols": ["selection_paren"]},
    {"name": "union_right", "symbols": ["selection"]},
    {"name": "union_right", "symbols": ["selection_paren"]},
    {"name": "union_statement$subexpression$1$ebnf$1", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)], "postprocess": id},
    {"name": "union_statement$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "union_statement$subexpression$1", "symbols": [(lexerAny.has("kw_union") ? {type: "kw_union"} : kw_union), "union_statement$subexpression$1$ebnf$1"]},
    {"name": "union_statement", "symbols": ["union_left", "union_statement$subexpression$1", "union_right"], "postprocess":  x => {
            return track(x, {
                type: toStr(x[1], ' '),
                left: unwrap(x[0]),
                right: unwrap(x[2]),
            });
        } },
    {"name": "prepare$ebnf$1$subexpression$1", "symbols": ["lparen", "data_type_list", "rparen"], "postprocess": get(1)},
    {"name": "prepare$ebnf$1", "symbols": ["prepare$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "prepare$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "prepare", "symbols": ["kw_prepare", "ident", "prepare$ebnf$1", (lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "statement_noprep"], "postprocess":  x => track(x, {
            type: 'prepare',
            name: asName(x[1]),
            ...x[2] && { args: x[2] },
            statement: unwrap(last(x)),
        }) },
    {"name": "deallocate$ebnf$1", "symbols": ["kw_prepare"], "postprocess": id},
    {"name": "deallocate$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "deallocate", "symbols": ["kw_deallocate", "deallocate$ebnf$1", "deallocate_target"], "postprocess":  x => track(x, {
            type: 'deallocate',
            target: x[2],
        }) },
    {"name": "deallocate_target", "symbols": ["deallocate_all"], "postprocess": unwrap},
    {"name": "deallocate_target", "symbols": ["deallocate_name"], "postprocess": unwrap},
    {"name": "deallocate_name", "symbols": ["ident"], "postprocess": x => track(x, asName(x[0]) )},
    {"name": "deallocate_all", "symbols": [(lexerAny.has("kw_all") ? {type: "kw_all"} : kw_all)], "postprocess": x => track(x, { option: 'all' })},
    {"name": "create_view_statements", "symbols": ["create_view"]},
    {"name": "create_view_statements", "symbols": ["create_materialized_view"]},
    {"name": "create_view$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_or") ? {type: "kw_or"} : kw_or), "kw_replace"]},
    {"name": "create_view$ebnf$1", "symbols": ["create_view$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "create_view$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_view$ebnf$2$subexpression$1", "symbols": ["kw_temp"]},
    {"name": "create_view$ebnf$2$subexpression$1", "symbols": ["kw_temporary"]},
    {"name": "create_view$ebnf$2", "symbols": ["create_view$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "create_view$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "create_view$ebnf$3", "symbols": ["kw_recursive"], "postprocess": id},
    {"name": "create_view$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "create_view$ebnf$4$subexpression$1$macrocall$2", "symbols": ["ident"]},
    {"name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "symbols": []},
    {"name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "create_view$ebnf$4$subexpression$1$macrocall$2"], "postprocess": last},
    {"name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "symbols": ["create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "create_view$ebnf$4$subexpression$1$macrocall$1", "symbols": ["create_view$ebnf$4$subexpression$1$macrocall$2", "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "create_view$ebnf$4$subexpression$1", "symbols": ["lparen", "create_view$ebnf$4$subexpression$1$macrocall$1", "rparen"], "postprocess": get(1)},
    {"name": "create_view$ebnf$4", "symbols": ["create_view$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "create_view$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "create_view$ebnf$5", "symbols": ["create_view_opts"], "postprocess": id},
    {"name": "create_view$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "create_view$ebnf$6$subexpression$1$subexpression$1", "symbols": ["kw_local"]},
    {"name": "create_view$ebnf$6$subexpression$1$subexpression$1", "symbols": ["kw_cascaded"]},
    {"name": "create_view$ebnf$6$subexpression$1", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "create_view$ebnf$6$subexpression$1$subexpression$1", (lexerAny.has("kw_check") ? {type: "kw_check"} : kw_check), "kw_option"], "postprocess": get(1)},
    {"name": "create_view$ebnf$6", "symbols": ["create_view$ebnf$6$subexpression$1"], "postprocess": id},
    {"name": "create_view$ebnf$6", "symbols": [], "postprocess": () => null},
    {"name": "create_view", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "create_view$ebnf$1", "create_view$ebnf$2", "create_view$ebnf$3", "kw_view", "qualified_name", "create_view$ebnf$4", "create_view$ebnf$5", (lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "selection", "create_view$ebnf$6"], "postprocess":  x => {
            return track(x, {
                type: 'create view',
                ... x[1] && {orReplace: true},
                ... x[2] && {temp: true},
                ... x[3] && {recursive: true},
                name: x[5],
                ... x[6] && {columnNames: x[6].map(asName)},
                ... x[7] && {parameters: fromEntries(x[7])},
                query: x[9],
                ... x[10] && { checkOption: toStr(x[10]) },
            })
        } },
    {"name": "create_view_opt", "symbols": ["ident", (lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq), "ident"], "postprocess": ([a, _, b]) => [toStr(a), toStr(b)]},
    {"name": "create_view_opts$macrocall$2", "symbols": ["create_view_opt"]},
    {"name": "create_view_opts$macrocall$1$ebnf$1", "symbols": []},
    {"name": "create_view_opts$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "create_view_opts$macrocall$2"], "postprocess": last},
    {"name": "create_view_opts$macrocall$1$ebnf$1", "symbols": ["create_view_opts$macrocall$1$ebnf$1", "create_view_opts$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "create_view_opts$macrocall$1", "symbols": ["create_view_opts$macrocall$2", "create_view_opts$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "create_view_opts", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "create_view_opts$macrocall$1"], "postprocess": last},
    {"name": "create_materialized_view$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id},
    {"name": "create_materialized_view$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$2", "symbols": ["ident"]},
    {"name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": []},
    {"name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "create_materialized_view$ebnf$2$subexpression$1$macrocall$2"], "postprocess": last},
    {"name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": ["create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1", "symbols": ["create_materialized_view$ebnf$2$subexpression$1$macrocall$2", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "create_materialized_view$ebnf$2$subexpression$1", "symbols": ["lparen", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1", "rparen"], "postprocess": get(1)},
    {"name": "create_materialized_view$ebnf$2", "symbols": ["create_materialized_view$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "create_materialized_view$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "create_materialized_view$ebnf$3", "symbols": ["create_view_opts"], "postprocess": id},
    {"name": "create_materialized_view$ebnf$3", "symbols": [], "postprocess": () => null},
    {"name": "create_materialized_view$ebnf$4$subexpression$1", "symbols": ["kw_tablespace", "ident"], "postprocess": last},
    {"name": "create_materialized_view$ebnf$4", "symbols": ["create_materialized_view$ebnf$4$subexpression$1"], "postprocess": id},
    {"name": "create_materialized_view$ebnf$4", "symbols": [], "postprocess": () => null},
    {"name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "symbols": ["kw_no"], "postprocess": id},
    {"name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_materialized_view$ebnf$5$subexpression$1", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "kw_data"]},
    {"name": "create_materialized_view$ebnf$5", "symbols": ["create_materialized_view$ebnf$5$subexpression$1"], "postprocess": id},
    {"name": "create_materialized_view$ebnf$5", "symbols": [], "postprocess": () => null},
    {"name": "create_materialized_view", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "kw_materialized", "kw_view", "create_materialized_view$ebnf$1", "qualified_name", "create_materialized_view$ebnf$2", "create_materialized_view$ebnf$3", "create_materialized_view$ebnf$4", (lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "selection", "create_materialized_view$ebnf$5"], "postprocess":  x => {
            return track(x, {
                type: 'create materialized view',
                ... x[3] && {ifNotExists: true},
                name: x[4],
                ... x[5] && {columnNames: x[6].map(asName)},
                ... x[6] && {parameters: fromEntries(x[6])},
                ... x[7] && {tablespace: asName(x[7]) },
                query: x[9],
                ... x[10] && { withData: toStr(x[10][1]) !== 'no' },
            })
        } },
    {"name": "refresh_view_statements$ebnf$1", "symbols": [(lexerAny.has("kw_concurrently") ? {type: "kw_concurrently"} : kw_concurrently)], "postprocess": id},
    {"name": "refresh_view_statements$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "symbols": ["kw_no"], "postprocess": id},
    {"name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "refresh_view_statements$ebnf$2$subexpression$1", "symbols": [(lexerAny.has("kw_with") ? {type: "kw_with"} : kw_with), "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "kw_data"]},
    {"name": "refresh_view_statements$ebnf$2", "symbols": ["refresh_view_statements$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "refresh_view_statements$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "refresh_view_statements", "symbols": ["kw_refresh", "kw_materialized", "kw_view", "refresh_view_statements$ebnf$1", "qname", "refresh_view_statements$ebnf$2"], "postprocess":  x => track(x, {
            type: 'refresh materialized view',
            ... !!x[3] ? { concurrently: true } : {},
            name: x[4],
            ... !!x[5] ? { withData: toStr(x[5][1]) !== 'no' } : {},
        }) },
    {"name": "functions_statements", "symbols": ["create_func"]},
    {"name": "functions_statements", "symbols": ["do_stm"]},
    {"name": "functions_statements", "symbols": ["drop_func"]},
    {"name": "create_func$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("kw_or") ? {type: "kw_or"} : kw_or), "kw_replace"]},
    {"name": "create_func$ebnf$1", "symbols": ["create_func$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "create_func$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_func$subexpression$1$ebnf$1$macrocall$2", "symbols": ["func_argdef"]},
    {"name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "symbols": []},
    {"name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "create_func$subexpression$1$ebnf$1$macrocall$2"], "postprocess": last},
    {"name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "create_func$subexpression$1$ebnf$1$macrocall$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$2", "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "create_func$subexpression$1$ebnf$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$1"], "postprocess": id},
    {"name": "create_func$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "create_func$subexpression$1", "symbols": ["lparen", "create_func$subexpression$1$ebnf$1", "rparen"], "postprocess": get(1)},
    {"name": "create_func$ebnf$2", "symbols": ["func_spec"]},
    {"name": "create_func$ebnf$2", "symbols": ["create_func$ebnf$2", "func_spec"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "create_func", "symbols": [(lexerAny.has("kw_create") ? {type: "kw_create"} : kw_create), "create_func$ebnf$1", "kw_function", "qname", "create_func$subexpression$1", "create_func$ebnf$2"], "postprocess":  (x, rej) => {
            const specs: any = {};
            for (const s of x[5]) {
                for (const k in s) {
                    if (k[0] !== '_' && k in specs) {
                        throw new Error('conflicting or redundant options ' + k);
                    }
                }
                Object.assign(specs, s);
            }
        
            return track(x, {
                type: 'create function',
                ...x[1] && {orReplace: true},
                name: x[3],
                arguments: x[4] ?? [],
                ...specs,
            });
        } },
    {"name": "func_argdef$ebnf$1", "symbols": ["func_argopts"], "postprocess": id},
    {"name": "func_argdef$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "func_argdef$ebnf$2", "symbols": ["func_argdefault"], "postprocess": id},
    {"name": "func_argdef$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "func_argdef", "symbols": ["func_argdef$ebnf$1", "data_type", "func_argdef$ebnf$2"], "postprocess":  x => track(x, {
            default: x[2],
            type: x[1],
            ...x[0],
        }) },
    {"name": "func_argdefault", "symbols": [(lexerAny.has("kw_default") ? {type: "kw_default"} : kw_default), "expr"], "postprocess": 
        x => x[1]
                           },
    {"name": "func_argdefault", "symbols": [(lexerAny.has("op_eq") ? {type: "op_eq"} : op_eq), "expr"], "postprocess": x => x[1]},
    {"name": "func_argopts$ebnf$1", "symbols": ["word"], "postprocess": id},
    {"name": "func_argopts$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "func_argopts", "symbols": ["func_argmod", "func_argopts$ebnf$1"], "postprocess":  x => track(x, {
            mode: toStr(x[0]),
            ...x[1] && { name: asName(x[1]) },
        }) },
    {"name": "func_argopts", "symbols": ["word"], "postprocess":  (x, rej) => {
            const name = asName(x);
            if (name === 'out' || name === 'inout' || name === 'variadic') {
                return rej; // avoid ambiguous syntax
            }
            return track(x, {name});
        } },
    {"name": "func_argmod", "symbols": [(lexerAny.has("kw_in") ? {type: "kw_in"} : kw_in)]},
    {"name": "func_argmod", "symbols": ["kw_out"]},
    {"name": "func_argmod", "symbols": ["kw_inout"]},
    {"name": "func_argmod", "symbols": ["kw_variadic"]},
    {"name": "func_spec", "symbols": ["kw_language", "word"], "postprocess": x => track(x, { language: asName(last(x)) })},
    {"name": "func_spec", "symbols": ["func_purity"], "postprocess": x => track(x, {purity: toStr(x)})},
    {"name": "func_spec$subexpression$1", "symbols": [(lexerAny.has("codeblock") ? {type: "codeblock"} : codeblock)]},
    {"name": "func_spec$subexpression$1", "symbols": ["string"]},
    {"name": "func_spec", "symbols": [(lexerAny.has("kw_as") ? {type: "kw_as"} : kw_as), "func_spec$subexpression$1"], "postprocess": x =>({code: toStr(last(x))})},
    {"name": "func_spec$ebnf$1", "symbols": [(lexerAny.has("kw_not") ? {type: "kw_not"} : kw_not)], "postprocess": id},
    {"name": "func_spec$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "func_spec$subexpression$2", "symbols": ["word"], "postprocess": kw('leakproof')},
    {"name": "func_spec", "symbols": ["func_spec$ebnf$1", "func_spec$subexpression$2"], "postprocess": x => track(x, { leakproof: !x[0] })},
    {"name": "func_spec", "symbols": ["func_returns"], "postprocess": x => track(x, { returns: unwrap(x) })},
    {"name": "func_spec$subexpression$3", "symbols": ["word"], "postprocess": kw('called')},
    {"name": "func_spec", "symbols": ["func_spec$subexpression$3", "oninp"], "postprocess": () => ({ onNullInput: 'call' })},
    {"name": "func_spec$subexpression$4", "symbols": ["word"], "postprocess": kw('returns')},
    {"name": "func_spec", "symbols": ["func_spec$subexpression$4", (lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null), "oninp"], "postprocess": () => ({ onNullInput: 'null' })},
    {"name": "func_spec$subexpression$5", "symbols": ["word"], "postprocess": kw('strict')},
    {"name": "func_spec", "symbols": ["func_spec$subexpression$5"], "postprocess": () => ({ onNullInput: 'strict' })},
    {"name": "func_purity", "symbols": ["word"], "postprocess": kw('immutable')},
    {"name": "func_purity", "symbols": ["word"], "postprocess": kw('stable')},
    {"name": "func_purity", "symbols": ["word"], "postprocess": kw('volatile')},
    {"name": "oninp$subexpression$1", "symbols": ["word"], "postprocess": kw('input')},
    {"name": "oninp", "symbols": [(lexerAny.has("kw_on") ? {type: "kw_on"} : kw_on), (lexerAny.has("kw_null") ? {type: "kw_null"} : kw_null), "oninp$subexpression$1"]},
    {"name": "func_returns", "symbols": ["kw_returns", "data_type"], "postprocess": last},
    {"name": "func_returns$macrocall$2", "symbols": ["func_ret_table_col"]},
    {"name": "func_returns$macrocall$1$ebnf$1", "symbols": []},
    {"name": "func_returns$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "func_returns$macrocall$2"], "postprocess": last},
    {"name": "func_returns$macrocall$1$ebnf$1", "symbols": ["func_returns$macrocall$1$ebnf$1", "func_returns$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "func_returns$macrocall$1", "symbols": ["func_returns$macrocall$2", "func_returns$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "func_returns", "symbols": ["kw_returns", (lexerAny.has("kw_table") ? {type: "kw_table"} : kw_table), "lparen", "func_returns$macrocall$1", "rparen"], "postprocess":  x => track(x, {
            kind: 'table',
            columns: x[3],
        }) },
    {"name": "func_ret_table_col", "symbols": ["word", "data_type"], "postprocess": x => track(x, {name: asName(x[0]), type: x[1]})},
    {"name": "do_stm$ebnf$1$subexpression$1", "symbols": ["kw_language", "word"], "postprocess": last},
    {"name": "do_stm$ebnf$1", "symbols": ["do_stm$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "do_stm$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "do_stm", "symbols": [(lexerAny.has("kw_do") ? {type: "kw_do"} : kw_do), "do_stm$ebnf$1", (lexerAny.has("codeblock") ? {type: "codeblock"} : codeblock)], "postprocess":  x => track(x, {
            type: 'do',
            ...x[1] && { language: asName(x[1])},
            code: x[2].value,
        }) },
    {"name": "drop_func$ebnf$1$subexpression$1", "symbols": ["kw_if", "kw_exists"]},
    {"name": "drop_func$ebnf$1", "symbols": ["drop_func$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "drop_func$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "drop_func$ebnf$2", "symbols": ["drop_func_overload"], "postprocess": id},
    {"name": "drop_func$ebnf$2", "symbols": [], "postprocess": () => null},
    {"name": "drop_func", "symbols": ["kw_drop", "kw_function", "drop_func$ebnf$1", "qname", "drop_func$ebnf$2"], "postprocess":  x => track(x, {
            type: 'drop function',
            ...x[2] && {ifExists: true},
            name: x[3],
            ...x[4] && {arguments: x[4]},
        }) },
    {"name": "drop_func_overload$macrocall$2", "symbols": ["drop_func_overload_col"]},
    {"name": "drop_func_overload$macrocall$1$ebnf$1", "symbols": []},
    {"name": "drop_func_overload$macrocall$1$ebnf$1$subexpression$1", "symbols": [(lexerAny.has("comma") ? {type: "comma"} : comma), "drop_func_overload$macrocall$2"], "postprocess": last},
    {"name": "drop_func_overload$macrocall$1$ebnf$1", "symbols": ["drop_func_overload$macrocall$1$ebnf$1", "drop_func_overload$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "drop_func_overload$macrocall$1", "symbols": ["drop_func_overload$macrocall$2", "drop_func_overload$macrocall$1$ebnf$1"], "postprocess":  ([head, tail]) => {
            return [unwrap(head), ...(tail.map(unwrap) || [])];
        } },
    {"name": "drop_func_overload", "symbols": ["lparen", "drop_func_overload$macrocall$1", "rparen"], "postprocess": get(1)},
    {"name": "drop_func_overload_col$ebnf$1", "symbols": ["word"], "postprocess": id},
    {"name": "drop_func_overload_col$ebnf$1", "symbols": [], "postprocess": () => null},
    {"name": "drop_func_overload_col", "symbols": ["drop_func_overload_col$ebnf$1", "qname"], "postprocess":  x => track(x, {
            type: x[1],
            ... x[0] && {name: asName(x[0])},
        }) },
    {"name": "main$ebnf$1", "symbols": []},
    {"name": "main$ebnf$1", "symbols": ["main$ebnf$1", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "main$ebnf$2", "symbols": []},
    {"name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["statement_separator"]},
    {"name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "main$ebnf$2$subexpression$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "statement"]},
    {"name": "main$ebnf$2", "symbols": ["main$ebnf$2", "main$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "main$ebnf$3", "symbols": []},
    {"name": "main$ebnf$3", "symbols": ["main$ebnf$3", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]])},
    {"name": "main", "symbols": ["main$ebnf$1", "statement", "main$ebnf$2", "main$ebnf$3"], "postprocess":  ([_, head, _tail]) => {
            const tail = _tail;
        
            const ret = [unwrap(head), ...tail.map((x: any) => unwrap(x[1]))];
        
            return ret.length === 1
                ? ret[0]
                : ret;
        } },
    {"name": "statement_separator", "symbols": [(lexerAny.has("semicolon") ? {type: "semicolon"} : semicolon)]},
    {"name": "statement", "symbols": ["statement_noprep"]},
    {"name": "statement", "symbols": ["prepare"]},
    {"name": "statement", "symbols": ["deallocate"]},
    {"name": "statement_noprep", "symbols": ["selection"]},
    {"name": "statement_noprep", "symbols": ["createtable_statement"]},
    {"name": "statement_noprep", "symbols": ["createextension_statement"]},
    {"name": "statement_noprep", "symbols": ["createindex_statement"]},
    {"name": "statement_noprep", "symbols": ["simplestatements_all"]},
    {"name": "statement_noprep", "symbols": ["insert_statement"]},
    {"name": "statement_noprep", "symbols": ["update_statement"]},
    {"name": "statement_noprep", "symbols": ["altertable_statement"]},
    {"name": "statement_noprep", "symbols": ["alterindex_statement"]},
    {"name": "statement_noprep", "symbols": ["delete_statement"]},
    {"name": "statement_noprep", "symbols": ["create_sequence_statement"]},
    {"name": "statement_noprep", "symbols": ["alter_sequence_statement"]},
    {"name": "statement_noprep", "symbols": ["drop_statement"]},
    {"name": "statement_noprep", "symbols": ["createtype_statement"]},
    {"name": "statement_noprep", "symbols": ["altertype_statement"]},
    {"name": "statement_noprep", "symbols": ["create_view_statements"]},
    {"name": "statement_noprep", "symbols": ["refresh_view_statements"]},
    {"name": "statement_noprep", "symbols": ["create_schema"]},
    {"name": "statement_noprep", "symbols": ["raise_statement"]},
    {"name": "statement_noprep", "symbols": ["comment_statement"]},
    {"name": "statement_noprep", "symbols": ["functions_statements"]},
    {"name": "selection", "symbols": ["select_statement"], "postprocess": unwrap},
    {"name": "selection", "symbols": ["select_values"], "postprocess": unwrap},
    {"name": "selection", "symbols": ["with_statement"], "postprocess": unwrap},
    {"name": "selection", "symbols": ["with_recursive_statement"], "postprocess": unwrap},
    {"name": "selection", "symbols": ["union_statement"], "postprocess": unwrap},
    {"name": "selection_paren", "symbols": ["lparen", "selection", "rparen"], "postprocess": get(1)}
  ],
  ParserStart: "main",
};

export default grammar;
